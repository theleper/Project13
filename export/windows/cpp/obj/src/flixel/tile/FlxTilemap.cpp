// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxCamera
#include <flixel/FlxCamera.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_graphics_FlxGraphic
#include <flixel/graphics/FlxGraphic.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFrame
#include <flixel/graphics/frames/FlxFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxFramesCollection
#include <flixel/graphics/frames/FlxFramesCollection.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxImageFrame
#include <flixel/graphics/frames/FlxImageFrame.h>
#endif
#ifndef INCLUDED_flixel_graphics_frames_FlxTileFrames
#include <flixel/graphics/frames/FlxTileFrames.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawBaseItem
#include <flixel/graphics/tile/FlxDrawBaseItem.h>
#endif
#ifndef INCLUDED_flixel_graphics_tile_FlxDrawTilesItem
#include <flixel/graphics/tile/FlxDrawTilesItem.h>
#endif
#ifndef INCLUDED_flixel_math_FlxCallbackPoint
#include <flixel/math/FlxCallbackPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxMatrix
#include <flixel/math/FlxMatrix.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_math_FlxRect
#include <flixel/math/FlxRect.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_BitmapFrontEnd
#include <flixel/system/frontEnds/BitmapFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_CameraFrontEnd
#include <flixel/system/frontEnds/CameraFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_DebuggerFrontEnd
#include <flixel/system/frontEnds/DebuggerFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_system_frontEnds_SignalFrontEnd
#include <flixel/system/frontEnds/SignalFrontEnd.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxBaseTilemap
#include <flixel/tile/FlxBaseTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTile
#include <flixel/tile/FlxTile.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemap
#include <flixel/tile/FlxTilemap.h>
#endif
#ifndef INCLUDED_flixel_tile_FlxTilemapBuffer
#include <flixel/tile/FlxTilemapBuffer.h>
#endif
#ifndef INCLUDED_flixel_util_FlxColorTransformUtil
#include <flixel/util/FlxColorTransformUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxDestroyUtil
#include <flixel/util/FlxDestroyUtil.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxRect
#include <flixel/util/FlxPool_flixel_math_FlxRect.h>
#endif
#ifndef INCLUDED_flixel_util_FlxSpriteUtil
#include <flixel/util/FlxSpriteUtil.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxSignal
#include <flixel/util/IFlxSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxBaseSignal
#include <flixel/util/_FlxSignal/FlxBaseSignal.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal0
#include <flixel/util/_FlxSignal/FlxSignal0.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal1
#include <flixel/util/_FlxSignal/FlxSignal1.h>
#endif
#ifndef INCLUDED_flixel_util__FlxSignal_FlxSignal2
#include <flixel/util/_FlxSignal/FlxSignal2.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BitmapData
#include <openfl/_legacy/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_BlendMode
#include <openfl/_legacy/display/BlendMode.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_CapsStyle
#include <openfl/_legacy/display/CapsStyle.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_DisplayObject
#include <openfl/_legacy/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_DisplayObjectContainer
#include <openfl/_legacy/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_Graphics
#include <openfl/_legacy/display/Graphics.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_IBitmapDrawable
#include <openfl/_legacy/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_InteractiveObject
#include <openfl/_legacy/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_JointStyle
#include <openfl/_legacy/display/JointStyle.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_LineScaleMode
#include <openfl/_legacy/display/LineScaleMode.h>
#endif
#ifndef INCLUDED_openfl__legacy_display_Sprite
#include <openfl/_legacy/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_EventDispatcher
#include <openfl/_legacy/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl__legacy_events_IEventDispatcher
#include <openfl/_legacy/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_ColorTransform
#include <openfl/_legacy/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Matrix
#include <openfl/_legacy/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Point
#include <openfl/_legacy/geom/Point.h>
#endif
#ifndef INCLUDED_openfl__legacy_geom_Rectangle
#include <openfl/_legacy/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_1146cbfc6764fb25_43_new,"flixel.tile.FlxTilemap","new",0xbe02531c,"flixel.tile.FlxTilemap.new","flixel/tile/FlxTilemap.hx",43,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_186_destroy,"flixel.tile.FlxTilemap","destroy",0xa7f2bdb6,"flixel.tile.FlxTilemap.destroy","flixel/tile/FlxTilemap.hx",186,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_233_set_frames,"flixel.tile.FlxTilemap","set_frames",0xb39c4aa7,"flixel.tile.FlxTilemap.set_frames","flixel/tile/FlxTilemap.hx",233,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_250_onGameResized,"flixel.tile.FlxTilemap","onGameResized",0x240fb4fb,"flixel.tile.FlxTilemap.onGameResized","flixel/tile/FlxTilemap.hx",250,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_255_onCameraChanged,"flixel.tile.FlxTilemap","onCameraChanged",0xe013f4ec,"flixel.tile.FlxTilemap.onCameraChanged","flixel/tile/FlxTilemap.hx",255,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_259_cacheGraphics,"flixel.tile.FlxTilemap","cacheGraphics",0x759126e9,"flixel.tile.FlxTilemap.cacheGraphics","flixel/tile/FlxTilemap.hx",259,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_283_initTileObjects,"flixel.tile.FlxTilemap","initTileObjects",0xb20b6ad2,"flixel.tile.FlxTilemap.initTileObjects","flixel/tile/FlxTilemap.hx",283,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_308_updateDebugTileBoundingBoxSolid,"flixel.tile.FlxTilemap","updateDebugTileBoundingBoxSolid",0xf2502658,"flixel.tile.FlxTilemap.updateDebugTileBoundingBoxSolid","flixel/tile/FlxTilemap.hx",308,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_313_updateDebugTileBoundingBoxNotSolid,"flixel.tile.FlxTilemap","updateDebugTileBoundingBoxNotSolid",0x299bee0b,"flixel.tile.FlxTilemap.updateDebugTileBoundingBoxNotSolid","flixel/tile/FlxTilemap.hx",313,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_318_updateDebugTileBoundingBoxPartial,"flixel.tile.FlxTilemap","updateDebugTileBoundingBoxPartial",0xa959eeee,"flixel.tile.FlxTilemap.updateDebugTileBoundingBoxPartial","flixel/tile/FlxTilemap.hx",318,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_322_updateDebugTile,"flixel.tile.FlxTilemap","updateDebugTile",0x0398ec94,"flixel.tile.FlxTilemap.updateDebugTile","flixel/tile/FlxTilemap.hx",322,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_346_computeDimensions,"flixel.tile.FlxTilemap","computeDimensions",0x3602f860,"flixel.tile.FlxTilemap.computeDimensions","flixel/tile/FlxTilemap.hx",346,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_356_updateMap,"flixel.tile.FlxTilemap","updateMap",0x271f1fcf,"flixel.tile.FlxTilemap.updateMap","flixel/tile/FlxTilemap.hx",356,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_369_drawDebugOnCamera,"flixel.tile.FlxTilemap","drawDebugOnCamera",0x0d929baf,"flixel.tile.FlxTilemap.drawDebugOnCamera","flixel/tile/FlxTilemap.hx",369,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_443_draw,"flixel.tile.FlxTilemap","draw",0x7d740dc8,"flixel.tile.FlxTilemap.draw","flixel/tile/FlxTilemap.hx",443,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_499_refreshBuffers,"flixel.tile.FlxTilemap","refreshBuffers",0x89f6f19c,"flixel.tile.FlxTilemap.refreshBuffers","flixel/tile/FlxTilemap.hx",499,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_526_setDirty,"flixel.tile.FlxTilemap","setDirty",0x6396ccd4,"flixel.tile.FlxTilemap.setDirty","flixel/tile/FlxTilemap.hx",526,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_547_overlapsWithCallback,"flixel.tile.FlxTilemap","overlapsWithCallback",0xe7b56cdb,"flixel.tile.FlxTilemap.overlapsWithCallback","flixel/tile/FlxTilemap.hx",547,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_648_getTileIndexByCoords,"flixel.tile.FlxTilemap","getTileIndexByCoords",0xb5ce22c7,"flixel.tile.FlxTilemap.getTileIndexByCoords","flixel/tile/FlxTilemap.hx",648,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_655_getTileCoordsByIndex,"flixel.tile.FlxTilemap","getTileCoordsByIndex",0xe0680d7d,"flixel.tile.FlxTilemap.getTileCoordsByIndex","flixel/tile/FlxTilemap.hx",655,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_673_getTileCoords,"flixel.tile.FlxTilemap","getTileCoords",0x02899bde,"flixel.tile.FlxTilemap.getTileCoords","flixel/tile/FlxTilemap.hx",673,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_710_follow,"flixel.tile.FlxTilemap","follow",0xe6a96c35,"flixel.tile.FlxTilemap.follow","flixel/tile/FlxTilemap.hx",710,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_728_ray,"flixel.tile.FlxTilemap","ray",0xbe0558a6,"flixel.tile.FlxTilemap.ray","flixel/tile/FlxTilemap.hx",728,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_838_tileToSprite,"flixel.tile.FlxTilemap","tileToSprite",0xe7482ef2,"flixel.tile.FlxTilemap.tileToSprite","flixel/tile/FlxTilemap.hx",838,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_865_updateBuffers,"flixel.tile.FlxTilemap","updateBuffers",0xf5face26,"flixel.tile.FlxTilemap.updateBuffers","flixel/tile/FlxTilemap.hx",865,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_877_drawTilemap,"flixel.tile.FlxTilemap","drawTilemap",0x2b20d346,"flixel.tile.FlxTilemap.drawTilemap","flixel/tile/FlxTilemap.hx",877,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1024_makeDebugTile,"flixel.tile.FlxTilemap","makeDebugTile",0xa1ed2d0f,"flixel.tile.FlxTilemap.makeDebugTile","flixel/tile/FlxTilemap.hx",1024,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1035_drawDebugTile,"flixel.tile.FlxTilemap","drawDebugTile",0x086b4839,"flixel.tile.FlxTilemap.drawDebugTile","flixel/tile/FlxTilemap.hx",1035,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1052_onDrawDebugChanged,"flixel.tile.FlxTilemap","onDrawDebugChanged",0x3243d108,"flixel.tile.FlxTilemap.onDrawDebugChanged","flixel/tile/FlxTilemap.hx",1052,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1062_updateTile,"flixel.tile.FlxTilemap","updateTile",0x18c3429b,"flixel.tile.FlxTilemap.updateTile","flixel/tile/FlxTilemap.hx",1062,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1071_createBuffer,"flixel.tile.FlxTilemap","createBuffer",0x170b42e0,"flixel.tile.FlxTilemap.createBuffer","flixel/tile/FlxTilemap.hx",1071,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1079_set_antialiasing,"flixel.tile.FlxTilemap","set_antialiasing",0x6cc568b5,"flixel.tile.FlxTilemap.set_antialiasing","flixel/tile/FlxTilemap.hx",1079,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1090_set_graphic,"flixel.tile.FlxTilemap","set_graphic",0xa0b86087,"flixel.tile.FlxTilemap.set_graphic","flixel/tile/FlxTilemap.hx",1090,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1107_set_pixelPerfectRender,"flixel.tile.FlxTilemap","set_pixelPerfectRender",0x5122f25e,"flixel.tile.FlxTilemap.set_pixelPerfectRender","flixel/tile/FlxTilemap.hx",1107,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1116_set_alpha,"flixel.tile.FlxTilemap","set_alpha",0xecd0277d,"flixel.tile.FlxTilemap.set_alpha","flixel/tile/FlxTilemap.hx",1116,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1123_set_color,"flixel.tile.FlxTilemap","set_color",0x1595f182,"flixel.tile.FlxTilemap.set_color","flixel/tile/FlxTilemap.hx",1123,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1133_updateColorTransform,"flixel.tile.FlxTilemap","updateColorTransform",0x6f14b936,"flixel.tile.FlxTilemap.updateColorTransform","flixel/tile/FlxTilemap.hx",1133,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1146_set_blend,"flixel.tile.FlxTilemap","set_blend",0x802e6870,"flixel.tile.FlxTilemap.set_blend","flixel/tile/FlxTilemap.hx",1146,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1152_setScaleXYCallback,"flixel.tile.FlxTilemap","setScaleXYCallback",0x2287ee32,"flixel.tile.FlxTilemap.setScaleXYCallback","flixel/tile/FlxTilemap.hx",1152,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1158_setScaleXCallback,"flixel.tile.FlxTilemap","setScaleXCallback",0x45b95971,"flixel.tile.FlxTilemap.setScaleXCallback","flixel/tile/FlxTilemap.hx",1158,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1171_setScaleYCallback,"flixel.tile.FlxTilemap","setScaleYCallback",0x18aac272,"flixel.tile.FlxTilemap.setScaleYCallback","flixel/tile/FlxTilemap.hx",1171,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1190_defaultTileToSprite,"flixel.tile.FlxTilemap","defaultTileToSprite",0xb4e0664b,"flixel.tile.FlxTilemap.defaultTileToSprite","flixel/tile/FlxTilemap.hx",1190,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1201_set_allowCollisions,"flixel.tile.FlxTilemap","set_allowCollisions",0x96e24689,"flixel.tile.FlxTilemap.set_allowCollisions","flixel/tile/FlxTilemap.hx",1201,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1211_set_debugBoundingBoxColorSolid,"flixel.tile.FlxTilemap","set_debugBoundingBoxColorSolid",0x6fe5cfdd,"flixel.tile.FlxTilemap.set_debugBoundingBoxColorSolid","flixel/tile/FlxTilemap.hx",1211,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1218_set_debugBoundingBoxColorNotSolid,"flixel.tile.FlxTilemap","set_debugBoundingBoxColorNotSolid",0xa41f45a6,"flixel.tile.FlxTilemap.set_debugBoundingBoxColorNotSolid","flixel/tile/FlxTilemap.hx",1218,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_1225_set_debugBoundingBoxColorPartial,"flixel.tile.FlxTilemap","set_debugBoundingBoxColorPartial",0xf6d0c3b3,"flixel.tile.FlxTilemap.set_debugBoundingBoxColorPartial","flixel/tile/FlxTilemap.hx",1225,0x448feb74)
HX_LOCAL_STACK_FRAME(_hx_pos_1146cbfc6764fb25_49_boot,"flixel.tile.FlxTilemap","boot",0x7c1f65f6,"flixel.tile.FlxTilemap.boot","flixel/tile/FlxTilemap.hx",49,0x448feb74)
namespace flixel{
namespace tile{

void FlxTilemap_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_1146cbfc6764fb25_43_new)
HXLINE( 152)		this->_checkBufferChanges = false;
HXLINE( 130)		this->_scaledTileHeight = ((Float)0);
HXLINE( 129)		this->_scaledTileWidth = ((Float)0);
HXLINE( 127)		this->_tileHeight = (int)0;
HXLINE( 123)		this->_tileWidth = (int)0;
HXLINE( 119)		this->_buffers = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 115)		this->_flashRect =  ::openfl::_legacy::geom::Rectangle_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 111)		this->_flashPoint =  ::openfl::_legacy::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE(  98)		this->blend = null();
HXLINE(  93)		this->colorTransform =  ::openfl::_legacy::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
HXLINE(  91)		this->alpha = ((Float)1.0);
HXLINE(  86)		this->color = (int)16777215;
HXLINE(  74)		 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN(  74)		point->_inPool = false;
HXDLIN(  74)		this->offset = point;
HXLINE(  68)		this->antialiasing = false;
HXLINE(  56)		this->useScaleHack = true;
HXLINE( 156)		super::__construct();
HXLINE( 158)		if (::flixel::FlxG_obj::renderTile) {
HXLINE( 160)			this->_helperPoint =  ::openfl::_legacy::geom::Point_obj::__alloc( HX_CTX ,null(),null());
HXLINE( 161)			this->_matrix =  ::flixel::math::FlxMatrix_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null());
            		}
HXLINE( 164)		this->scale =  ::flixel::math::FlxCallbackPoint_obj::__alloc( HX_CTX ,this->setScaleXCallback_dyn(),this->setScaleYCallback_dyn(),this->setScaleXYCallback_dyn());
HXLINE( 165)		this->scale->set((int)1,(int)1);
HXLINE( 167)		::flixel::FlxG_obj::signals->gameResized->add(this->onGameResized_dyn());
HXLINE( 168)		::flixel::FlxG_obj::cameras->cameraAdded->add(this->onCameraChanged_dyn());
HXLINE( 169)		::flixel::FlxG_obj::cameras->cameraRemoved->add(this->onCameraChanged_dyn());
HXLINE( 170)		::flixel::FlxG_obj::cameras->cameraResized->add(this->onCameraChanged_dyn());
HXLINE( 173)		this->set_debugBoundingBoxColorSolid((int)-16744448);
HXLINE( 174)		this->set_debugBoundingBoxColorPartial((int)-16181);
HXLINE( 175)		this->set_debugBoundingBoxColorNotSolid((int)0);
HXLINE( 177)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 178)			::flixel::FlxG_obj::debugger->drawDebugChanged->add(this->onDrawDebugChanged_dyn());
            		}
            	}

Dynamic FlxTilemap_obj::__CreateEmpty() { return new FlxTilemap_obj; }

void *FlxTilemap_obj::_hx_vtable = 0;

Dynamic FlxTilemap_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FlxTilemap_obj > _hx_result = new FlxTilemap_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool FlxTilemap_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2e105115) {
		if (inClassId<=(int)0x25a685e0) {
			return inClassId==(int)0x00000001 || inClassId==(int)0x25a685e0;
		} else {
			return inClassId==(int)0x2e105115;
		}
	} else {
		return inClassId==(int)0x725f80f5 || inClassId==(int)0x75a66d6a;
	}
}

void FlxTilemap_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_186_destroy)
HXLINE( 187)		this->_flashPoint = null();
HXLINE( 188)		this->_flashRect = null();
HXLINE( 190)		this->_tileObjects = ::flixel::util::FlxDestroyUtil_obj::destroyArray(this->_tileObjects);
HXLINE( 191)		this->_buffers = ::flixel::util::FlxDestroyUtil_obj::destroyArray(this->_buffers);
HXLINE( 193)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 196)			this->_debugRect = null();
HXLINE( 197)			this->_debugTileNotSolid = ::flixel::util::FlxDestroyUtil_obj::dispose(this->_debugTileNotSolid);
HXLINE( 198)			this->_debugTilePartial = ::flixel::util::FlxDestroyUtil_obj::dispose(this->_debugTilePartial);
HXLINE( 199)			this->_debugTileSolid = ::flixel::util::FlxDestroyUtil_obj::dispose(this->_debugTileSolid);
            		}
            		else {
HXLINE( 204)			this->_helperPoint = null();
HXLINE( 205)			this->_matrix = null();
            		}
HXLINE( 208)		this->set_frames(null());
HXLINE( 209)		this->set_graphic(null());
HXLINE( 212)		this->scale = ( ( ::flixel::math::FlxPoint)(::flixel::util::FlxDestroyUtil_obj::destroy(this->scale)) );
HXLINE( 213)		this->offset = ( ( ::flixel::math::FlxPoint)(::flixel::util::FlxDestroyUtil_obj::put(this->offset)) );
HXLINE( 215)		this->colorTransform = null();
HXLINE( 217)		::flixel::FlxG_obj::signals->gameResized->remove(this->onGameResized_dyn());
HXLINE( 218)		::flixel::FlxG_obj::cameras->cameraAdded->remove(this->onCameraChanged_dyn());
HXLINE( 219)		::flixel::FlxG_obj::cameras->cameraRemoved->remove(this->onCameraChanged_dyn());
HXLINE( 220)		::flixel::FlxG_obj::cameras->cameraResized->remove(this->onCameraChanged_dyn());
HXLINE( 223)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 224)			::flixel::FlxG_obj::debugger->drawDebugChanged->remove(this->onDrawDebugChanged_dyn());
            		}
HXLINE( 227)		this->shader = null();
HXLINE( 229)		this->super::destroy();
            	}


 ::flixel::graphics::frames::FlxFramesCollection FlxTilemap_obj::set_frames( ::flixel::graphics::frames::FlxFramesCollection value){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_233_set_frames)
HXLINE( 234)		this->frames = value;
HXLINE( 236)		if (hx::IsNotNull( value )) {
HXLINE( 238)			this->_tileWidth = ::Std_obj::_hx_int(value->frames->__get((int)0).StaticCast<  ::flixel::graphics::frames::FlxFrame >()->sourceSize->x);
HXLINE( 239)			this->_tileHeight = ::Std_obj::_hx_int(value->frames->__get((int)0).StaticCast<  ::flixel::graphics::frames::FlxFrame >()->sourceSize->y);
HXLINE( 240)			this->_flashRect->setTo((int)0,(int)0,this->_tileWidth,this->_tileHeight);
HXLINE( 241)			this->set_graphic(value->parent);
HXLINE( 242)			this->postGraphicLoad();
            		}
HXLINE( 245)		return value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,set_frames,return )

void FlxTilemap_obj::onGameResized(int _,int _1){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_250_onGameResized)
HXDLIN( 250)		this->_checkBufferChanges = true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemap_obj,onGameResized,(void))

void FlxTilemap_obj::onCameraChanged( ::flixel::FlxCamera _){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_255_onCameraChanged)
HXDLIN( 255)		this->_checkBufferChanges = true;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,onCameraChanged,(void))

void FlxTilemap_obj::cacheGraphics(int TileWidth,int TileHeight, ::Dynamic TileGraphic){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_259_cacheGraphics)
HXLINE( 260)		if (::Std_obj::is(TileGraphic,hx::ClassOf< ::flixel::graphics::frames::FlxFramesCollection >())) {
HXLINE( 262)			this->set_frames(( ( ::flixel::graphics::frames::FlxFramesCollection)(TileGraphic) ));
HXLINE( 263)			return;
            		}
HXLINE( 266)		 ::flixel::graphics::FlxGraphic graph = ::flixel::FlxG_obj::bitmap->add(TileGraphic,null(),null());
HXLINE( 267)		if (hx::IsNull( graph )) {
HXLINE( 268)			return;
            		}
HXLINE( 271)		this->_tileWidth = TileWidth;
HXLINE( 272)		if ((this->_tileWidth <= (int)0)) {
HXLINE( 273)			this->_tileWidth = graph->height;
            		}
HXLINE( 275)		this->_tileHeight = TileHeight;
HXLINE( 276)		if ((this->_tileHeight <= (int)0)) {
HXLINE( 277)			this->_tileHeight = this->_tileWidth;
            		}
HXLINE( 279)		Float X = this->_tileWidth;
HXDLIN( 279)		Float Y = this->_tileHeight;
HXDLIN( 279)		 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set(X,Y);
HXDLIN( 279)		point->_inPool = false;
HXDLIN( 279)		this->set_frames(::flixel::graphics::frames::FlxTileFrames_obj::fromGraphic(graph,point,null(),null()));
            	}


void FlxTilemap_obj::initTileObjects(){
            	HX_GC_STACKFRAME(&_hx_pos_1146cbfc6764fb25_283_initTileObjects)
HXLINE( 284)		if (hx::IsNull( this->frames )) {
HXLINE( 285)			return;
            		}
HXLINE( 287)		this->_tileObjects = ::flixel::util::FlxDestroyUtil_obj::destroyArray(this->_tileObjects);
HXLINE( 289)		this->_tileObjects = ::Array_obj< ::Dynamic>::__new();
HXLINE( 291)		int length = this->frames->frames->length;
HXLINE( 292)		length = (length + this->_startingIndex);
HXLINE( 294)		{
HXLINE( 294)			int _g1 = (int)0;
HXDLIN( 294)			int _g = length;
HXDLIN( 294)			while((_g1 < _g)){
HXLINE( 294)				_g1 = (_g1 + (int)1);
HXDLIN( 294)				int i = (_g1 - (int)1);
HXLINE( 295)				::Array< ::Dynamic> _hx_tmp = this->_tileObjects;
HXDLIN( 295)				int _hx_tmp1 = this->_tileWidth;
HXDLIN( 295)				int _hx_tmp2 = this->_tileHeight;
HXDLIN( 295)				int _hx_tmp3;
HXDLIN( 295)				if ((i >= this->_collideIndex)) {
HXLINE( 295)					_hx_tmp3 = this->allowCollisions;
            				}
            				else {
HXLINE( 295)					_hx_tmp3 = (int)0;
            				}
HXDLIN( 295)				_hx_tmp[i] =  ::flixel::tile::FlxTile_obj::__alloc( HX_CTX ,hx::ObjectPtr<OBJ_>(this),i,_hx_tmp1,_hx_tmp2,(i >= this->_drawIndex),_hx_tmp3);
            			}
            		}
HXLINE( 299)		this->updateDebugTileBoundingBoxSolid();
HXLINE( 300)		this->updateDebugTileBoundingBoxNotSolid();
HXLINE( 301)		this->updateDebugTileBoundingBoxPartial();
            	}


void FlxTilemap_obj::updateDebugTileBoundingBoxSolid(){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_308_updateDebugTileBoundingBoxSolid)
HXDLIN( 308)		this->_debugTileSolid = this->updateDebugTile(this->_debugTileSolid,this->debugBoundingBoxColorSolid);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTilemap_obj,updateDebugTileBoundingBoxSolid,(void))

void FlxTilemap_obj::updateDebugTileBoundingBoxNotSolid(){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_313_updateDebugTileBoundingBoxNotSolid)
HXDLIN( 313)		this->_debugTileNotSolid = this->updateDebugTile(this->_debugTileNotSolid,this->debugBoundingBoxColorNotSolid);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTilemap_obj,updateDebugTileBoundingBoxNotSolid,(void))

void FlxTilemap_obj::updateDebugTileBoundingBoxPartial(){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_318_updateDebugTileBoundingBoxPartial)
HXDLIN( 318)		this->_debugTilePartial = this->updateDebugTile(this->_debugTilePartial,this->debugBoundingBoxColorPartial);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTilemap_obj,updateDebugTileBoundingBoxPartial,(void))

 ::openfl::_legacy::display::BitmapData FlxTilemap_obj::updateDebugTile( ::openfl::_legacy::display::BitmapData tileBitmap,int color){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_322_updateDebugTile)
HXLINE( 323)		if (::flixel::FlxG_obj::renderTile) {
HXLINE( 324)			return null();
            		}
HXLINE( 326)		bool _hx_tmp;
HXDLIN( 326)		if ((this->_tileWidth > (int)0)) {
HXLINE( 326)			_hx_tmp = (this->_tileHeight <= (int)0);
            		}
            		else {
HXLINE( 326)			_hx_tmp = true;
            		}
HXDLIN( 326)		if (_hx_tmp) {
HXLINE( 327)			return tileBitmap;
            		}
HXLINE( 329)		bool _hx_tmp1;
HXDLIN( 329)		if (hx::IsNotNull( tileBitmap )) {
HXLINE( 329)			int _hx_tmp2 = tileBitmap->get_width();
HXDLIN( 329)			if ((_hx_tmp2 == this->_tileWidth)) {
HXLINE( 329)				int _hx_tmp3 = tileBitmap->get_height();
HXDLIN( 329)				_hx_tmp1 = (_hx_tmp3 != this->_tileHeight);
            			}
            			else {
HXLINE( 329)				_hx_tmp1 = true;
            			}
            		}
            		else {
HXLINE( 329)			_hx_tmp1 = false;
            		}
HXDLIN( 329)		if (_hx_tmp1) {
HXLINE( 330)			tileBitmap = ::flixel::util::FlxDestroyUtil_obj::dispose(tileBitmap);
            		}
HXLINE( 332)		if (hx::IsNull( tileBitmap )) {
HXLINE( 333)			tileBitmap = this->makeDebugTile(color);
            		}
            		else {
HXLINE( 336)			tileBitmap->fillRect(tileBitmap->get_rect(),(int)0);
HXLINE( 337)			this->drawDebugTile(tileBitmap,color);
            		}
HXLINE( 340)		this->setDirty(null());
HXLINE( 341)		return tileBitmap;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemap_obj,updateDebugTile,return )

void FlxTilemap_obj::computeDimensions(){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_346_computeDimensions)
HXLINE( 347)		this->_scaledTileWidth = (this->_tileWidth * this->scale->x);
HXLINE( 348)		this->_scaledTileHeight = (this->_tileHeight * this->scale->y);
HXLINE( 351)		this->set_width((this->widthInTiles * this->_scaledTileWidth));
HXLINE( 352)		this->set_height((this->heightInTiles * this->_scaledTileHeight));
            	}


void FlxTilemap_obj::updateMap(){
            	HX_GC_STACKFRAME(&_hx_pos_1146cbfc6764fb25_356_updateMap)
HXLINE( 358)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 359)			this->_debugRect =  ::openfl::_legacy::geom::Rectangle_obj::__alloc( HX_CTX ,(int)0,(int)0,this->_tileWidth,this->_tileHeight);
            		}
HXLINE( 362)		int numTiles = this->_tileObjects->get_length();
HXLINE( 363)		{
HXLINE( 363)			int _g1 = (int)0;
HXDLIN( 363)			int _g = numTiles;
HXDLIN( 363)			while((_g1 < _g)){
HXLINE( 363)				_g1 = (_g1 + (int)1);
HXDLIN( 363)				int i = (_g1 - (int)1);
HXLINE( 364)				this->updateTile(i);
            			}
            		}
            	}


void FlxTilemap_obj::drawDebugOnCamera( ::flixel::FlxCamera Camera){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_369_drawDebugOnCamera)
HXLINE( 370)		if (!(::flixel::FlxG_obj::renderTile)) {
HXLINE( 371)			return;
            		}
HXLINE( 373)		 ::flixel::tile::FlxTilemapBuffer buffer = null();
HXLINE( 374)		int l = ::flixel::FlxG_obj::cameras->list->length;
HXLINE( 376)		{
HXLINE( 376)			int _g1 = (int)0;
HXDLIN( 376)			int _g = l;
HXDLIN( 376)			while((_g1 < _g)){
HXLINE( 376)				_g1 = (_g1 + (int)1);
HXDLIN( 376)				int i = (_g1 - (int)1);
HXLINE( 378)				if (hx::IsEq( ::flixel::FlxG_obj::cameras->list->__get(i).StaticCast<  ::flixel::FlxCamera >(),Camera )) {
HXLINE( 380)					buffer = this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXLINE( 381)					goto _hx_goto_15;
            				}
            			}
            			_hx_goto_15:;
            		}
HXLINE( 385)		if (hx::IsNull( buffer )) {
HXLINE( 386)			return;
            		}
HXLINE( 389)		Float _hx_tmp = this->x;
HXDLIN( 389)		this->_helperPoint->x = (_hx_tmp - (Camera->scroll->x * this->scrollFactor->x));
HXLINE( 390)		Float _hx_tmp1 = this->y;
HXDLIN( 390)		this->_helperPoint->y = (_hx_tmp1 - (Camera->scroll->y * this->scrollFactor->y));
HXLINE( 392)		Float rectWidth = this->_scaledTileWidth;
HXLINE( 393)		Float rectHeight = this->_scaledTileHeight;
HXLINE( 394)		 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 394)		_this->x = (int)0;
HXDLIN( 394)		_this->y = (int)0;
HXDLIN( 394)		_this->width = rectWidth;
HXDLIN( 394)		_this->height = rectHeight;
HXDLIN( 394)		 ::flixel::math::FlxRect rect = _this;
HXDLIN( 394)		rect->_inPool = false;
HXDLIN( 394)		 ::flixel::math::FlxRect rect1 = rect;
HXLINE( 398)		 ::flixel::math::FlxPoint _hx_tmp2 = this->_point;
HXDLIN( 398)		_hx_tmp2->set_x(((Camera->scroll->x * this->scrollFactor->x) - this->x));
HXLINE( 399)		 ::flixel::math::FlxPoint _hx_tmp3 = this->_point;
HXDLIN( 399)		_hx_tmp3->set_y(((Camera->scroll->y * this->scrollFactor->y) - this->y));
HXLINE( 400)		int screenXInTiles = ::Math_obj::floor(((Float)this->_point->x / (Float)this->_scaledTileWidth));
HXLINE( 401)		int screenYInTiles = ::Math_obj::floor(((Float)this->_point->y / (Float)this->_scaledTileHeight));
HXLINE( 402)		int screenRows = buffer->rows;
HXLINE( 403)		int screenColumns = buffer->columns;
HXLINE( 406)		 ::Dynamic Max = (this->widthInTiles - screenColumns);
HXDLIN( 406)		Float lowerBound;
HXDLIN( 406)		if ((screenXInTiles < (int)0)) {
HXLINE( 406)			lowerBound = (int)0;
            		}
            		else {
HXLINE( 406)			lowerBound = screenXInTiles;
            		}
HXDLIN( 406)		Float screenXInTiles1;
HXDLIN( 406)		bool screenXInTiles2;
HXDLIN( 406)		if (hx::IsNotNull( Max )) {
HXLINE( 406)			screenXInTiles2 = hx::IsGreater( lowerBound,Max );
            		}
            		else {
HXLINE( 406)			screenXInTiles2 = false;
            		}
HXDLIN( 406)		if (screenXInTiles2) {
HXLINE( 406)			screenXInTiles1 = Max;
            		}
            		else {
HXLINE( 406)			screenXInTiles1 = lowerBound;
            		}
HXDLIN( 406)		screenXInTiles = ::Std_obj::_hx_int(screenXInTiles1);
HXLINE( 407)		 ::Dynamic Max1 = (this->heightInTiles - screenRows);
HXDLIN( 407)		Float lowerBound1;
HXDLIN( 407)		if ((screenYInTiles < (int)0)) {
HXLINE( 407)			lowerBound1 = (int)0;
            		}
            		else {
HXLINE( 407)			lowerBound1 = screenYInTiles;
            		}
HXDLIN( 407)		Float screenYInTiles1;
HXDLIN( 407)		bool screenYInTiles2;
HXDLIN( 407)		if (hx::IsNotNull( Max1 )) {
HXLINE( 407)			screenYInTiles2 = hx::IsGreater( lowerBound1,Max1 );
            		}
            		else {
HXLINE( 407)			screenYInTiles2 = false;
            		}
HXDLIN( 407)		if (screenYInTiles2) {
HXLINE( 407)			screenYInTiles1 = Max1;
            		}
            		else {
HXLINE( 407)			screenYInTiles1 = lowerBound1;
            		}
HXDLIN( 407)		screenYInTiles = ::Std_obj::_hx_int(screenYInTiles1);
HXLINE( 409)		int rowIndex = ((screenYInTiles * this->widthInTiles) + screenXInTiles);
HXLINE( 410)		int columnIndex;
HXLINE( 411)		 ::flixel::tile::FlxTile tile;
HXLINE( 413)		{
HXLINE( 413)			int _g11 = (int)0;
HXDLIN( 413)			int _g2 = screenRows;
HXDLIN( 413)			while((_g11 < _g2)){
HXLINE( 413)				_g11 = (_g11 + (int)1);
HXDLIN( 413)				int row = (_g11 - (int)1);
HXLINE( 415)				columnIndex = rowIndex;
HXLINE( 417)				{
HXLINE( 417)					int _g3 = (int)0;
HXDLIN( 417)					int _g21 = screenColumns;
HXDLIN( 417)					while((_g3 < _g21)){
HXLINE( 417)						_g3 = (_g3 + (int)1);
HXDLIN( 417)						int column = (_g3 - (int)1);
HXLINE( 419)						::Array< ::Dynamic> tile1 = this->_tileObjects;
HXDLIN( 419)						tile = tile1->__get(this->_data->__get(columnIndex)).StaticCast<  ::flixel::tile::FlxTile >();
HXLINE( 421)						bool _hx_tmp4;
HXDLIN( 421)						if (hx::IsNotNull( tile )) {
HXLINE( 421)							_hx_tmp4 = tile->visible;
            						}
            						else {
HXLINE( 421)							_hx_tmp4 = false;
            						}
HXDLIN( 421)						if (_hx_tmp4) {
HXLINE( 423)							Float _hx_tmp5 = this->_helperPoint->x;
HXDLIN( 423)							rect1->x = (_hx_tmp5 + (hx::Mod(columnIndex,this->widthInTiles) * rectWidth));
HXLINE( 424)							Float _hx_tmp6 = this->_helperPoint->y;
HXDLIN( 424)							rect1->y = (_hx_tmp6 + (::Math_obj::floor(((Float)columnIndex / (Float)this->widthInTiles)) * rectHeight));
HXLINE( 425)							 ::openfl::_legacy::display::Graphics _hx_tmp7 = Camera->debugLayer->get_graphics();
HXLINE( 426)							int tile2 = tile->allowCollisions;
HXLINE( 425)							this->drawDebugBoundingBox(_hx_tmp7,rect1,tile2,(tile->allowCollisions != (int)4369));
            						}
HXLINE( 429)						columnIndex = (columnIndex + (int)1);
            					}
            				}
HXLINE( 432)				rowIndex = (rowIndex + this->widthInTiles);
            			}
            		}
HXLINE( 435)		if (!(rect1->_inPool)) {
HXLINE( 435)			rect1->_inPool = true;
HXDLIN( 435)			rect1->_weak = false;
HXDLIN( 435)			::flixel::math::FlxRect_obj::_pool->putUnsafe(rect1);
            		}
            	}


void FlxTilemap_obj::draw(){
            	HX_GC_STACKFRAME(&_hx_pos_1146cbfc6764fb25_443_draw)
HXLINE( 445)		if (hx::IsNull( this->graphic )) {
HXLINE( 446)			return;
            		}
HXLINE( 448)		if (this->_checkBufferChanges) {
HXLINE( 450)			this->refreshBuffers();
HXLINE( 451)			this->_checkBufferChanges = false;
            		}
HXLINE( 454)		 ::flixel::FlxCamera camera;
HXLINE( 455)		 ::flixel::tile::FlxTilemapBuffer buffer;
HXLINE( 456)		int l = this->get_cameras()->length;
HXLINE( 458)		{
HXLINE( 458)			int _g1 = (int)0;
HXDLIN( 458)			int _g = l;
HXDLIN( 458)			while((_g1 < _g)){
HXLINE( 458)				_g1 = (_g1 + (int)1);
HXDLIN( 458)				int i = (_g1 - (int)1);
HXLINE( 460)				camera = this->get_cameras()->__get(i).StaticCast<  ::flixel::FlxCamera >();
HXLINE( 462)				bool _hx_tmp;
HXDLIN( 462)				if (!(!(camera->visible))) {
HXLINE( 462)					_hx_tmp = !(camera->exists);
            				}
            				else {
HXLINE( 462)					_hx_tmp = true;
            				}
HXDLIN( 462)				if (_hx_tmp) {
HXLINE( 463)					continue;
            				}
HXLINE( 465)				if (hx::IsNull( this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >() )) {
HXLINE( 466)					::Array< ::Dynamic> _hx_tmp1 = this->_buffers;
HXDLIN( 466)					 ::flixel::tile::FlxTilemapBuffer buffer1 =  ::flixel::tile::FlxTilemapBuffer_obj::__alloc( HX_CTX ,this->_tileWidth,this->_tileHeight,this->widthInTiles,this->heightInTiles,camera,this->scale->x,this->scale->y);
HXDLIN( 466)					buffer1->pixelPerfectRender = this->pixelPerfectRender;
HXDLIN( 466)					buffer1->antialiasing = this->antialiasing;
HXDLIN( 466)					_hx_tmp1[i] = buffer1;
            				}
HXLINE( 468)				buffer = this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXLINE( 470)				if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 472)					{
HXLINE( 472)						 ::flixel::math::FlxPoint _this = this->getScreenPosition(this->_point,camera)->subtractPoint(this->offset);
HXDLIN( 472)						Float Y = buffer->y;
HXDLIN( 472)						{
HXLINE( 472)							 ::flixel::math::FlxPoint _g2 = _this;
HXDLIN( 472)							_g2->set_x((_g2->x + buffer->x));
            						}
HXDLIN( 472)						{
HXLINE( 472)							 ::flixel::math::FlxPoint _g3 = _this;
HXDLIN( 472)							_g3->set_y((_g3->y + Y));
            						}
            					}
HXLINE( 473)					bool _hx_tmp2;
HXDLIN( 473)					bool _hx_tmp3;
HXDLIN( 473)					bool _hx_tmp4;
HXDLIN( 473)					bool _hx_tmp5;
HXDLIN( 473)					if (!(buffer->dirty)) {
HXLINE( 473)						_hx_tmp5 = (this->_point->x > (int)0);
            					}
            					else {
HXLINE( 473)						_hx_tmp5 = true;
            					}
HXDLIN( 473)					if (!(_hx_tmp5)) {
HXLINE( 473)						_hx_tmp4 = (this->_point->y > (int)0);
            					}
            					else {
HXLINE( 473)						_hx_tmp4 = true;
            					}
HXDLIN( 473)					if (!(_hx_tmp4)) {
HXLINE( 473)						_hx_tmp3 = ((this->_point->x + buffer->width) < camera->width);
            					}
            					else {
HXLINE( 473)						_hx_tmp3 = true;
            					}
HXDLIN( 473)					if (!(_hx_tmp3)) {
HXLINE( 473)						_hx_tmp2 = ((this->_point->y + buffer->height) < camera->height);
            					}
            					else {
HXLINE( 473)						_hx_tmp2 = true;
            					}
HXDLIN( 473)					buffer->dirty = _hx_tmp2;
HXLINE( 475)					if (buffer->dirty) {
HXLINE( 476)						this->drawTilemap(buffer,camera);
            					}
HXLINE( 478)					{
HXLINE( 478)						 ::flixel::math::FlxPoint _this1 = this->getScreenPosition(this->_point,camera)->subtractPoint(this->offset);
HXDLIN( 478)						Float Y1 = buffer->y;
HXDLIN( 478)						{
HXLINE( 478)							 ::flixel::math::FlxPoint _g4 = _this1;
HXDLIN( 478)							_g4->set_x((_g4->x + buffer->x));
            						}
HXDLIN( 478)						{
HXLINE( 478)							 ::flixel::math::FlxPoint _g5 = _this1;
HXDLIN( 478)							_g5->set_y((_g5->y + Y1));
            						}
HXDLIN( 478)						 ::flixel::math::FlxPoint _this2 = _this1;
HXDLIN( 478)						 ::openfl::_legacy::geom::Point FlashPoint = this->_flashPoint;
HXDLIN( 478)						if (hx::IsNull( FlashPoint )) {
HXLINE( 478)							FlashPoint =  ::openfl::_legacy::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            						}
HXDLIN( 478)						FlashPoint->x = _this2->x;
HXDLIN( 478)						FlashPoint->y = _this2->y;
            					}
HXLINE( 479)					buffer->draw(camera,this->_flashPoint,this->scale->x,this->scale->y);
            				}
            				else {
HXLINE( 483)					this->drawTilemap(buffer,camera);
            				}
HXLINE( 487)				::flixel::FlxBasic_obj::visibleCount++;
            			}
            		}
HXLINE( 492)		if (::flixel::FlxG_obj::debugger->drawDebug) {
HXLINE( 493)			this->drawDebug();
            		}
            	}


void FlxTilemap_obj::refreshBuffers(){
            	HX_GC_STACKFRAME(&_hx_pos_1146cbfc6764fb25_499_refreshBuffers)
HXDLIN( 499)		int _g1 = (int)0;
HXDLIN( 499)		int _g = this->get_cameras()->length;
HXDLIN( 499)		while((_g1 < _g)){
HXDLIN( 499)			_g1 = (_g1 + (int)1);
HXDLIN( 499)			int i = (_g1 - (int)1);
HXLINE( 501)			 ::flixel::FlxCamera camera = this->get_cameras()->__get(i).StaticCast<  ::flixel::FlxCamera >();
HXLINE( 502)			 ::flixel::tile::FlxTilemapBuffer buffer = this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXLINE( 505)			::flixel::tile::FlxTilemap_obj::_helperBuffer->updateColumns(this->_tileWidth,this->widthInTiles,this->scale->x,camera);
HXLINE( 506)			::flixel::tile::FlxTilemap_obj::_helperBuffer->updateRows(this->_tileHeight,this->heightInTiles,this->scale->y,camera);
HXLINE( 509)			bool _hx_tmp;
HXDLIN( 509)			bool _hx_tmp1;
HXDLIN( 509)			if (hx::IsNotNull( buffer )) {
HXLINE( 509)				_hx_tmp1 = (::flixel::tile::FlxTilemap_obj::_helperBuffer->columns != buffer->columns);
            			}
            			else {
HXLINE( 509)				_hx_tmp1 = true;
            			}
HXDLIN( 509)			if (!(_hx_tmp1)) {
HXLINE( 509)				_hx_tmp = (::flixel::tile::FlxTilemap_obj::_helperBuffer->rows != buffer->rows);
            			}
            			else {
HXLINE( 509)				_hx_tmp = true;
            			}
HXDLIN( 509)			if (_hx_tmp) {
HXLINE( 511)				if (hx::IsNotNull( buffer )) {
HXLINE( 512)					buffer->destroy();
            				}
HXLINE( 514)				::Array< ::Dynamic> _hx_tmp2 = this->_buffers;
HXDLIN( 514)				 ::flixel::tile::FlxTilemapBuffer buffer1 =  ::flixel::tile::FlxTilemapBuffer_obj::__alloc( HX_CTX ,this->_tileWidth,this->_tileHeight,this->widthInTiles,this->heightInTiles,camera,this->scale->x,this->scale->y);
HXDLIN( 514)				buffer1->pixelPerfectRender = this->pixelPerfectRender;
HXDLIN( 514)				buffer1->antialiasing = this->antialiasing;
HXDLIN( 514)				_hx_tmp2[i] = buffer1;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTilemap_obj,refreshBuffers,(void))

void FlxTilemap_obj::setDirty(hx::Null< bool >  __o_Dirty){
bool Dirty = __o_Dirty.Default(true);
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_526_setDirty)
HXLINE( 527)		if (::flixel::FlxG_obj::renderTile) {
HXLINE( 528)			return;
            		}
HXLINE( 530)		{
HXLINE( 530)			int _g = (int)0;
HXDLIN( 530)			::Array< ::Dynamic> _g1 = this->_buffers;
HXDLIN( 530)			while((_g < _g1->length)){
HXLINE( 530)				 ::flixel::tile::FlxTilemapBuffer buffer = _g1->__get(_g).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXDLIN( 530)				_g = (_g + (int)1);
HXLINE( 531)				if (hx::IsNotNull( buffer )) {
HXLINE( 532)					buffer->dirty = Dirty;
            				}
            			}
            		}
            	}


bool FlxTilemap_obj::overlapsWithCallback( ::flixel::FlxObject Object, ::Dynamic Callback,hx::Null< bool >  __o_FlipCallbackParams, ::flixel::math::FlxPoint Position){
bool FlipCallbackParams = __o_FlipCallbackParams.Default(false);
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_547_overlapsWithCallback)
HXLINE( 548)		bool results = false;
HXLINE( 550)		Float xPos = this->x;
HXLINE( 551)		Float yPos = this->y;
HXLINE( 553)		if (hx::IsNotNull( Position )) {
HXLINE( 555)			xPos = Position->x;
HXLINE( 556)			yPos = Position->y;
            		}
HXLINE( 560)		int selectionX = ::Math_obj::floor(((Float)(Object->x - xPos) / (Float)this->_scaledTileWidth));
HXLINE( 561)		int selectionY = ::Math_obj::floor(((Float)(Object->y - yPos) / (Float)this->_scaledTileHeight));
HXLINE( 562)		Float selectionWidth = Object->get_width();
HXDLIN( 562)		int selectionWidth1 = ((selectionX + ::Math_obj::ceil(((Float)selectionWidth / (Float)this->_scaledTileWidth))) + (int)1);
HXLINE( 563)		Float selectionHeight = Object->get_height();
HXDLIN( 563)		int selectionHeight1 = ((selectionY + ::Math_obj::ceil(((Float)selectionHeight / (Float)this->_scaledTileHeight))) + (int)1);
HXLINE( 566)		 ::Dynamic Max = this->widthInTiles;
HXDLIN( 566)		Float lowerBound;
HXDLIN( 566)		if ((selectionX < (int)0)) {
HXLINE( 566)			lowerBound = (int)0;
            		}
            		else {
HXLINE( 566)			lowerBound = selectionX;
            		}
HXDLIN( 566)		Float selectionX1;
HXDLIN( 566)		bool selectionX2;
HXDLIN( 566)		if (hx::IsNotNull( Max )) {
HXLINE( 566)			selectionX2 = hx::IsGreater( lowerBound,Max );
            		}
            		else {
HXLINE( 566)			selectionX2 = false;
            		}
HXDLIN( 566)		if (selectionX2) {
HXLINE( 566)			selectionX1 = Max;
            		}
            		else {
HXLINE( 566)			selectionX1 = lowerBound;
            		}
HXDLIN( 566)		selectionX = ::Std_obj::_hx_int(selectionX1);
HXLINE( 567)		 ::Dynamic Max1 = this->heightInTiles;
HXDLIN( 567)		Float lowerBound1;
HXDLIN( 567)		if ((selectionY < (int)0)) {
HXLINE( 567)			lowerBound1 = (int)0;
            		}
            		else {
HXLINE( 567)			lowerBound1 = selectionY;
            		}
HXDLIN( 567)		Float selectionY1;
HXDLIN( 567)		bool selectionY2;
HXDLIN( 567)		if (hx::IsNotNull( Max1 )) {
HXLINE( 567)			selectionY2 = hx::IsGreater( lowerBound1,Max1 );
            		}
            		else {
HXLINE( 567)			selectionY2 = false;
            		}
HXDLIN( 567)		if (selectionY2) {
HXLINE( 567)			selectionY1 = Max1;
            		}
            		else {
HXLINE( 567)			selectionY1 = lowerBound1;
            		}
HXDLIN( 567)		selectionY = ::Std_obj::_hx_int(selectionY1);
HXLINE( 568)		 ::Dynamic Max2 = this->widthInTiles;
HXDLIN( 568)		Float lowerBound2;
HXDLIN( 568)		if ((selectionWidth1 < (int)0)) {
HXLINE( 568)			lowerBound2 = (int)0;
            		}
            		else {
HXLINE( 568)			lowerBound2 = selectionWidth1;
            		}
HXDLIN( 568)		Float selectionWidth2;
HXDLIN( 568)		bool selectionWidth3;
HXDLIN( 568)		if (hx::IsNotNull( Max2 )) {
HXLINE( 568)			selectionWidth3 = hx::IsGreater( lowerBound2,Max2 );
            		}
            		else {
HXLINE( 568)			selectionWidth3 = false;
            		}
HXDLIN( 568)		if (selectionWidth3) {
HXLINE( 568)			selectionWidth2 = Max2;
            		}
            		else {
HXLINE( 568)			selectionWidth2 = lowerBound2;
            		}
HXDLIN( 568)		selectionWidth1 = ::Std_obj::_hx_int(selectionWidth2);
HXLINE( 569)		 ::Dynamic Max3 = this->heightInTiles;
HXDLIN( 569)		Float lowerBound3;
HXDLIN( 569)		if ((selectionHeight1 < (int)0)) {
HXLINE( 569)			lowerBound3 = (int)0;
            		}
            		else {
HXLINE( 569)			lowerBound3 = selectionHeight1;
            		}
HXDLIN( 569)		Float selectionHeight2;
HXDLIN( 569)		bool selectionHeight3;
HXDLIN( 569)		if (hx::IsNotNull( Max3 )) {
HXLINE( 569)			selectionHeight3 = hx::IsGreater( lowerBound3,Max3 );
            		}
            		else {
HXLINE( 569)			selectionHeight3 = false;
            		}
HXDLIN( 569)		if (selectionHeight3) {
HXLINE( 569)			selectionHeight2 = Max3;
            		}
            		else {
HXLINE( 569)			selectionHeight2 = lowerBound3;
            		}
HXDLIN( 569)		selectionHeight1 = ::Std_obj::_hx_int(selectionHeight2);
HXLINE( 572)		int rowStart = (selectionY * this->widthInTiles);
HXLINE( 573)		int column;
HXLINE( 574)		 ::flixel::tile::FlxTile tile;
HXLINE( 575)		bool overlapFound;
HXLINE( 576)		Float deltaX = (xPos - this->last->x);
HXLINE( 577)		Float deltaY = (yPos - this->last->y);
HXLINE( 579)		{
HXLINE( 579)			int _g1 = selectionY;
HXDLIN( 579)			int _g = selectionHeight1;
HXDLIN( 579)			while((_g1 < _g)){
HXLINE( 579)				_g1 = (_g1 + (int)1);
HXDLIN( 579)				int row = (_g1 - (int)1);
HXLINE( 581)				column = selectionX;
HXLINE( 583)				while((column < selectionWidth1)){
HXLINE( 585)					int index = (rowStart + column);
HXLINE( 586)					bool _hx_tmp;
HXDLIN( 586)					if ((index >= (int)0)) {
HXLINE( 586)						_hx_tmp = (index > (this->_data->length - (int)1));
            					}
            					else {
HXLINE( 586)						_hx_tmp = true;
            					}
HXDLIN( 586)					if (_hx_tmp) {
HXLINE( 588)						column = (column + (int)1);
HXLINE( 589)						continue;
            					}
HXLINE( 592)					int dataIndex = this->_data->__get(index);
HXLINE( 593)					if ((dataIndex < (int)0)) {
HXLINE( 595)						column = (column + (int)1);
HXLINE( 596)						continue;
            					}
HXLINE( 599)					tile = Dynamic( this->_tileObjects->__get(dataIndex)).StaticCast<  ::flixel::tile::FlxTile >();
HXLINE( 600)					tile->set_width(this->_scaledTileWidth);
HXLINE( 601)					tile->set_height(this->_scaledTileHeight);
HXLINE( 602)					tile->set_x((xPos + (column * tile->get_width())));
HXLINE( 603)					tile->set_y((yPos + (row * tile->get_height())));
HXLINE( 604)					 ::flixel::math::FlxPoint tile1 = tile->last;
HXDLIN( 604)					tile1->set_x((tile->x - deltaX));
HXLINE( 605)					 ::flixel::math::FlxPoint tile2 = tile->last;
HXDLIN( 605)					tile2->set_y((tile->y - deltaY));
HXLINE( 608)					bool overlapFound1;
HXDLIN( 608)					bool overlapFound2;
HXDLIN( 608)					Float Object1 = Object->x;
HXDLIN( 608)					Float overlapFound3 = (Object1 + Object->get_width());
HXDLIN( 608)					if ((overlapFound3 > tile->x)) {
HXLINE( 608)						Float Object2 = Object->x;
HXDLIN( 608)						Float tile3 = tile->x;
HXDLIN( 608)						overlapFound2 = (Object2 < (tile3 + tile->get_width()));
            					}
            					else {
HXLINE( 608)						overlapFound2 = false;
            					}
HXDLIN( 608)					if (overlapFound2) {
HXLINE( 609)						Float Object3 = Object->y;
HXDLIN( 609)						Float overlapFound4 = (Object3 + Object->get_height());
HXLINE( 608)						overlapFound1 = (overlapFound4 > tile->y);
            					}
            					else {
HXLINE( 608)						overlapFound1 = false;
            					}
HXDLIN( 608)					if (overlapFound1) {
HXLINE( 609)						Float Object4 = Object->y;
HXDLIN( 609)						Float tile4 = tile->y;
HXDLIN( 609)						overlapFound = (Object4 < (tile4 + tile->get_height()));
            					}
            					else {
HXLINE( 608)						overlapFound = false;
            					}
HXLINE( 611)					if ((tile->allowCollisions != (int)0)) {
HXLINE( 613)						if (hx::IsNotNull( Callback )) {
HXLINE( 615)							if (FlipCallbackParams) {
HXLINE( 617)								overlapFound = ( (bool)(Callback(Object,tile)) );
            							}
            							else {
HXLINE( 621)								overlapFound = ( (bool)(Callback(tile,Object)) );
            							}
            						}
            					}
HXLINE( 626)					if (overlapFound) {
HXLINE( 628)						bool _hx_tmp1;
HXDLIN( 628)						if (hx::IsNotNull( tile->callbackFunction )) {
HXLINE( 628)							if (hx::IsNotNull( tile->filter )) {
HXLINE( 628)								_hx_tmp1 = ::Std_obj::is(Object,tile->filter);
            							}
            							else {
HXLINE( 628)								_hx_tmp1 = true;
            							}
            						}
            						else {
HXLINE( 628)							_hx_tmp1 = false;
            						}
HXDLIN( 628)						if (_hx_tmp1) {
HXLINE( 630)							tile->mapIndex = (rowStart + column);
HXLINE( 631)							tile->callbackFunction(tile,Object);
            						}
HXLINE( 634)						if ((tile->allowCollisions != (int)0)) {
HXLINE( 635)							results = true;
            						}
            					}
HXLINE( 638)					column = (column + (int)1);
            				}
HXLINE( 641)				rowStart = (rowStart + this->widthInTiles);
            			}
            		}
HXLINE( 644)		return results;
            	}


int FlxTilemap_obj::getTileIndexByCoords( ::flixel::math::FlxPoint Coord){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_648_getTileIndexByCoords)
HXLINE( 649)		int result = ::Std_obj::_hx_int(((Float)(Coord->y - this->y) / (Float)this->_scaledTileHeight));
HXDLIN( 649)		int result1 = (result * this->widthInTiles);
HXDLIN( 649)		int result2 = (result1 + ::Std_obj::_hx_int(((Float)(Coord->x - this->x) / (Float)this->_scaledTileWidth)));
HXLINE( 650)		if (Coord->_weak) {
HXLINE( 650)			Coord->put();
            		}
HXLINE( 651)		return result2;
            	}


 ::flixel::math::FlxPoint FlxTilemap_obj::getTileCoordsByIndex(int Index,hx::Null< bool >  __o_Midpoint){
bool Midpoint = __o_Midpoint.Default(true);
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_655_getTileCoordsByIndex)
HXLINE( 656)		Float X = this->x;
HXDLIN( 656)		Float X1 = (X + (hx::Mod(Index,this->widthInTiles) * this->_scaledTileWidth));
HXDLIN( 656)		Float Y = this->y;
HXDLIN( 656)		int Y1 = ::Std_obj::_hx_int(((Float)Index / (Float)this->widthInTiles));
HXDLIN( 656)		Float Y2 = (Y + (Y1 * this->_scaledTileHeight));
HXDLIN( 656)		 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set(X1,Y2);
HXDLIN( 656)		point->_inPool = false;
HXDLIN( 656)		 ::flixel::math::FlxPoint point1 = point;
HXLINE( 657)		if (Midpoint) {
HXLINE( 659)			{
HXLINE( 659)				 ::flixel::math::FlxPoint _g = point1;
HXDLIN( 659)				Float _g1 = _g->x;
HXDLIN( 659)				_g->set_x((_g1 + (this->_scaledTileWidth * ((Float)0.5))));
            			}
HXLINE( 660)			{
HXLINE( 660)				 ::flixel::math::FlxPoint _g2 = point1;
HXDLIN( 660)				Float _g3 = _g2->y;
HXDLIN( 660)				_g2->set_y((_g3 + (this->_scaledTileHeight * ((Float)0.5))));
            			}
            		}
HXLINE( 662)		return point1;
            	}


::Array< ::Dynamic> FlxTilemap_obj::getTileCoords(int Index,hx::Null< bool >  __o_Midpoint){
bool Midpoint = __o_Midpoint.Default(true);
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_673_getTileCoords)
HXLINE( 674)		::Array< ::Dynamic> array = null();
HXLINE( 676)		 ::flixel::math::FlxPoint point;
HXLINE( 677)		int l = (this->widthInTiles * this->heightInTiles);
HXLINE( 679)		{
HXLINE( 679)			int _g1 = (int)0;
HXDLIN( 679)			int _g = l;
HXDLIN( 679)			while((_g1 < _g)){
HXLINE( 679)				_g1 = (_g1 + (int)1);
HXDLIN( 679)				int i = (_g1 - (int)1);
HXLINE( 681)				if ((this->_data->__get(i) == Index)) {
HXLINE( 683)					Float X = this->x;
HXDLIN( 683)					Float X1 = (X + (hx::Mod(i,this->widthInTiles) * this->_scaledTileWidth));
HXDLIN( 683)					Float Y = this->y;
HXDLIN( 683)					int Y1 = ::Std_obj::_hx_int(((Float)i / (Float)this->widthInTiles));
HXDLIN( 683)					Float Y2 = (Y + (Y1 * this->_scaledTileHeight));
HXDLIN( 683)					 ::flixel::math::FlxPoint point1 = ::flixel::math::FlxPoint_obj::_pool->get()->set(X1,Y2);
HXDLIN( 683)					point1->_inPool = false;
HXDLIN( 683)					point = point1;
HXLINE( 685)					if (Midpoint) {
HXLINE( 687)						{
HXLINE( 687)							 ::flixel::math::FlxPoint _g2 = point;
HXDLIN( 687)							Float _g21 = _g2->x;
HXDLIN( 687)							_g2->set_x((_g21 + (this->_scaledTileWidth * ((Float)0.5))));
            						}
HXLINE( 688)						{
HXLINE( 688)							 ::flixel::math::FlxPoint _g22 = point;
HXDLIN( 688)							Float _g23 = _g22->y;
HXDLIN( 688)							_g22->set_y((_g23 + (this->_scaledTileHeight * ((Float)0.5))));
            						}
            					}
HXLINE( 691)					if (hx::IsNull( array )) {
HXLINE( 693)						array = ::Array_obj< ::Dynamic>::__new();
            					}
HXLINE( 695)					array->push(point);
            				}
            			}
            		}
HXLINE( 699)		return array;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemap_obj,getTileCoords,return )

void FlxTilemap_obj::follow( ::flixel::FlxCamera Camera,hx::Null< int >  __o_Border,hx::Null< bool >  __o_UpdateWorld){
int Border = __o_Border.Default(0);
bool UpdateWorld = __o_UpdateWorld.Default(true);
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_710_follow)
HXLINE( 711)		if (hx::IsNull( Camera )) {
HXLINE( 712)			Camera = ::flixel::FlxG_obj::camera;
            		}
HXLINE( 714)		Float _hx_tmp = this->x;
HXDLIN( 714)		Float _hx_tmp1 = (_hx_tmp + (Border * this->_scaledTileWidth));
HXDLIN( 714)		Float _hx_tmp2 = this->y;
HXDLIN( 714)		Float _hx_tmp3 = (_hx_tmp2 + (Border * this->_scaledTileHeight));
HXDLIN( 714)		Float _hx_tmp4 = this->get_width();
HXDLIN( 714)		Float _hx_tmp5 = (_hx_tmp4 - ((Border * this->_scaledTileWidth) * (int)2));
HXDLIN( 714)		Float _hx_tmp6 = this->get_height();
HXDLIN( 714)		Camera->setScrollBoundsRect(_hx_tmp1,_hx_tmp3,_hx_tmp5,(_hx_tmp6 - ((Border * this->_scaledTileHeight) * (int)2)),UpdateWorld);
            	}


HX_DEFINE_DYNAMIC_FUNC3(FlxTilemap_obj,follow,(void))

bool FlxTilemap_obj::ray( ::flixel::math::FlxPoint Start, ::flixel::math::FlxPoint End, ::flixel::math::FlxPoint Result,hx::Null< Float >  __o_Resolution){
Float Resolution = __o_Resolution.Default(1);
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_728_ray)
HXLINE( 729)		Float step = this->_scaledTileWidth;
HXLINE( 731)		if ((this->_scaledTileHeight < this->_scaledTileWidth)) {
HXLINE( 732)			step = this->_scaledTileHeight;
            		}
HXLINE( 734)		step = ((Float)step / (Float)Resolution);
HXLINE( 735)		Float deltaX = (End->x - Start->x);
HXLINE( 736)		Float deltaY = (End->y - Start->y);
HXLINE( 737)		Float distance = ::Math_obj::sqrt(((deltaX * deltaX) + (deltaY * deltaY)));
HXLINE( 738)		int steps = ::Math_obj::ceil(((Float)distance / (Float)step));
HXLINE( 739)		Float stepX = ((Float)deltaX / (Float)steps);
HXLINE( 740)		Float stepY = ((Float)deltaY / (Float)steps);
HXLINE( 741)		Float curX = ((Start->x - stepX) - this->x);
HXLINE( 742)		Float curY = ((Start->y - stepY) - this->y);
HXLINE( 743)		int tileX;
HXLINE( 744)		int tileY;
HXLINE( 745)		int i = (int)0;
HXLINE( 747)		if (Start->_weak) {
HXLINE( 747)			Start->put();
            		}
HXLINE( 748)		if (End->_weak) {
HXLINE( 748)			End->put();
            		}
HXLINE( 750)		while((i < steps)){
HXLINE( 752)			curX = (curX + stepX);
HXLINE( 753)			curY = (curY + stepY);
HXLINE( 755)			bool _hx_tmp;
HXDLIN( 755)			bool _hx_tmp1;
HXDLIN( 755)			bool _hx_tmp2;
HXDLIN( 755)			if (!((curX < (int)0))) {
HXLINE( 755)				_hx_tmp2 = (curX > this->get_width());
            			}
            			else {
HXLINE( 755)				_hx_tmp2 = true;
            			}
HXDLIN( 755)			if (!(_hx_tmp2)) {
HXLINE( 755)				_hx_tmp1 = (curY < (int)0);
            			}
            			else {
HXLINE( 755)				_hx_tmp1 = true;
            			}
HXDLIN( 755)			if (!(_hx_tmp1)) {
HXLINE( 755)				_hx_tmp = (curY > this->get_height());
            			}
            			else {
HXLINE( 755)				_hx_tmp = true;
            			}
HXDLIN( 755)			if (_hx_tmp) {
HXLINE( 757)				i = (i + (int)1);
HXLINE( 758)				continue;
            			}
HXLINE( 761)			tileX = ::Math_obj::floor(((Float)curX / (Float)this->_scaledTileWidth));
HXLINE( 762)			tileY = ::Math_obj::floor(((Float)curY / (Float)this->_scaledTileHeight));
HXLINE( 764)			::Array< ::Dynamic> _hx_tmp3 = this->_tileObjects;
HXDLIN( 764)			::Array< int > _hx_tmp4 = this->_data;
HXDLIN( 764)			if ((_hx_tmp3->__get(_hx_tmp4->__get(((tileY * this->widthInTiles) + tileX))).StaticCast<  ::flixel::tile::FlxTile >()->allowCollisions != (int)0)) {
HXLINE( 767)				tileX = (tileX * ::Std_obj::_hx_int(this->_scaledTileWidth));
HXLINE( 768)				tileY = (tileY * ::Std_obj::_hx_int(this->_scaledTileHeight));
HXLINE( 769)				Float rx = (int)0;
HXLINE( 770)				Float ry = (int)0;
HXLINE( 771)				Float q;
HXLINE( 772)				Float lx = (curX - stepX);
HXLINE( 773)				Float ly = (curY - stepY);
HXLINE( 776)				q = tileX;
HXLINE( 778)				if ((deltaX < (int)0)) {
HXLINE( 780)					q = (q + this->_scaledTileWidth);
            				}
HXLINE( 783)				rx = q;
HXLINE( 784)				ry = (ly + (stepY * ((Float)(q - lx) / (Float)stepX)));
HXLINE( 786)				bool _hx_tmp5;
HXDLIN( 786)				if ((ry >= tileY)) {
HXLINE( 786)					_hx_tmp5 = (ry <= (tileY + this->_scaledTileHeight));
            				}
            				else {
HXLINE( 786)					_hx_tmp5 = false;
            				}
HXDLIN( 786)				if (_hx_tmp5) {
HXLINE( 788)					if (hx::IsNull( Result )) {
HXLINE( 790)						 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN( 790)						point->_inPool = false;
HXDLIN( 790)						Result = point;
            					}
HXLINE( 793)					Result->set(rx,ry);
HXLINE( 794)					return false;
            				}
HXLINE( 798)				q = tileY;
HXLINE( 800)				if ((deltaY < (int)0)) {
HXLINE( 802)					q = (q + this->_scaledTileHeight);
            				}
HXLINE( 805)				rx = (lx + (stepX * ((Float)(q - ly) / (Float)stepY)));
HXLINE( 806)				ry = q;
HXLINE( 808)				bool _hx_tmp6;
HXDLIN( 808)				if ((rx >= tileX)) {
HXLINE( 808)					_hx_tmp6 = (rx <= (tileX + this->_scaledTileWidth));
            				}
            				else {
HXLINE( 808)					_hx_tmp6 = false;
            				}
HXDLIN( 808)				if (_hx_tmp6) {
HXLINE( 810)					if (hx::IsNull( Result )) {
HXLINE( 812)						 ::flixel::math::FlxPoint point1 = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN( 812)						point1->_inPool = false;
HXDLIN( 812)						Result = point1;
            					}
HXLINE( 815)					Result->set(rx,ry);
HXLINE( 816)					return false;
            				}
HXLINE( 819)				return true;
            			}
HXLINE( 821)			i = (i + (int)1);
            		}
HXLINE( 824)		return true;
            	}


 ::flixel::FlxSprite FlxTilemap_obj::tileToSprite(int X,int Y,hx::Null< int >  __o_NewTile, ::Dynamic SpriteFactory){
int NewTile = __o_NewTile.Default(0);
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_838_tileToSprite)
HXLINE( 839)		if (hx::IsNull( SpriteFactory )) {
HXLINE( 840)			SpriteFactory = this->defaultTileToSprite_dyn();
            		}
HXLINE( 842)		int rowIndex = (X + (Y * this->widthInTiles));
HXLINE( 843)		::Array< ::Dynamic> tile = this->_tileObjects;
HXDLIN( 843)		 ::flixel::tile::FlxTile tile1 = tile->__get(this->_data->__get(rowIndex)).StaticCast<  ::flixel::tile::FlxTile >();
HXLINE( 844)		 ::flixel::graphics::frames::FlxImageFrame image = null();
HXLINE( 846)		bool _hx_tmp;
HXDLIN( 846)		if (hx::IsNotNull( tile1 )) {
HXLINE( 846)			_hx_tmp = tile1->visible;
            		}
            		else {
HXLINE( 846)			_hx_tmp = false;
            		}
HXDLIN( 846)		if (_hx_tmp) {
HXLINE( 847)			image = ::flixel::graphics::frames::FlxImageFrame_obj::fromFrame(tile1->frame);
            		}
            		else {
HXLINE( 849)			 ::flixel::graphics::FlxGraphic image1 = this->graphic;
HXDLIN( 849)			Float Width = this->_tileWidth;
HXDLIN( 849)			Float Height = this->_tileHeight;
HXDLIN( 849)			 ::flixel::math::FlxRect _this = ::flixel::math::FlxRect_obj::_pool->get();
HXDLIN( 849)			_this->x = (int)0;
HXDLIN( 849)			_this->y = (int)0;
HXDLIN( 849)			_this->width = Width;
HXDLIN( 849)			_this->height = Height;
HXDLIN( 849)			 ::flixel::math::FlxRect rect = _this;
HXDLIN( 849)			rect->_inPool = false;
HXDLIN( 849)			image = ::flixel::graphics::frames::FlxImageFrame_obj::fromEmptyFrame(image1,rect);
            		}
HXLINE( 851)		Float tileX = (((X * this->_tileWidth) * this->scale->x) + this->x);
HXLINE( 852)		Float tileY = (((Y * this->_tileHeight) * this->scale->y) + this->y);
HXLINE( 853)		 ::flixel::math::FlxPoint point = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN( 853)		point->_inPool = false;
HXDLIN( 853)		 ::flixel::math::FlxPoint _this1 = point;
HXDLIN( 853)		 ::flixel::math::FlxPoint point1 = this->scale;
HXDLIN( 853)		_this1->set_x(point1->x);
HXDLIN( 853)		_this1->set_y(point1->y);
HXDLIN( 853)		if (point1->_weak) {
HXLINE( 853)			point1->put();
            		}
HXDLIN( 853)		 ::flixel::FlxSprite tileSprite = ( ( ::flixel::FlxSprite)(SpriteFactory( ::Dynamic(hx::Anon_obj::Create(6)
            			->setFixed(0,HX_("blend",51,e8,f4,b4),this->blend)
            			->setFixed(1,HX_("x",78,00,00,00),tileX)
            			->setFixed(2,HX_("y",79,00,00,00),tileY)
            			->setFixed(3,HX_("alpha",5e,a7,96,21),this->alpha)
            			->setFixed(4,HX_("graphic",a8,5a,07,74),image)
            			->setFixed(5,HX_("scale",8a,ce,ce,78),_this1)))) );
HXLINE( 855)		if ((NewTile >= (int)0)) {
HXLINE( 856)			this->setTile(X,Y,NewTile,null());
            		}
HXLINE( 858)		return tileSprite;
            	}


HX_DEFINE_DYNAMIC_FUNC4(FlxTilemap_obj,tileToSprite,return )

void FlxTilemap_obj::updateBuffers(){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_865_updateBuffers)
HXLINE( 866)		::flixel::util::FlxDestroyUtil_obj::destroyArray(this->_buffers);
HXLINE( 867)		this->_buffers = ::Array_obj< ::Dynamic>::__new(0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTilemap_obj,updateBuffers,(void))

void FlxTilemap_obj::drawTilemap( ::flixel::tile::FlxTilemapBuffer Buffer, ::flixel::FlxCamera Camera){
            	HX_GC_STACKFRAME(&_hx_pos_1146cbfc6764fb25_877_drawTilemap)
HXLINE( 878)		bool isColored;
HXDLIN( 878)		if ((this->alpha == (int)1)) {
HXLINE( 878)			isColored = (this->color != (int)16777215);
            		}
            		else {
HXLINE( 878)			isColored = true;
            		}
HXLINE( 881)		Float drawX = (int)0;
HXLINE( 882)		Float drawY = (int)0;
HXLINE( 883)		Float scaledWidth = (int)0;
HXLINE( 884)		Float scaledHeight = (int)0;
HXLINE( 885)		 ::flixel::graphics::tile::FlxDrawTilesItem drawItem = null();
HXLINE( 887)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 889)			Buffer->fill(null());
            		}
            		else {
HXLINE( 893)			{
HXLINE( 893)				 ::flixel::math::FlxPoint _this = this->getScreenPosition(this->_point,Camera)->subtractPoint(this->offset);
HXDLIN( 893)				 ::openfl::_legacy::geom::Point FlashPoint = this->_helperPoint;
HXDLIN( 893)				if (hx::IsNull( FlashPoint )) {
HXLINE( 893)					FlashPoint =  ::openfl::_legacy::geom::Point_obj::__alloc( HX_CTX ,null(),null());
            				}
HXDLIN( 893)				FlashPoint->x = _this->x;
HXDLIN( 893)				FlashPoint->y = _this->y;
            			}
HXLINE( 895)			Float _hx_tmp;
HXDLIN( 895)			if (this->isPixelPerfectRender(Camera)) {
HXLINE( 895)				_hx_tmp = ::Math_obj::floor(this->_helperPoint->x);
            			}
            			else {
HXLINE( 895)				_hx_tmp = this->_helperPoint->x;
            			}
HXDLIN( 895)			this->_helperPoint->x = _hx_tmp;
HXLINE( 896)			Float _hx_tmp1;
HXDLIN( 896)			if (this->isPixelPerfectRender(Camera)) {
HXLINE( 896)				_hx_tmp1 = ::Math_obj::floor(this->_helperPoint->y);
            			}
            			else {
HXLINE( 896)				_hx_tmp1 = this->_helperPoint->y;
            			}
HXDLIN( 896)			this->_helperPoint->y = _hx_tmp1;
HXLINE( 898)			scaledWidth = this->_scaledTileWidth;
HXLINE( 899)			scaledHeight = this->_scaledTileHeight;
HXLINE( 901)			bool hasColorOffsets;
HXDLIN( 901)			if (hx::IsNotNull( this->colorTransform )) {
HXLINE( 901)				hasColorOffsets = ::flixel::util::FlxColorTransformUtil_obj::hasRGBAOffsets(this->colorTransform);
            			}
            			else {
HXLINE( 901)				hasColorOffsets = false;
            			}
HXLINE( 902)			drawItem = Camera->startQuadBatch(this->graphic,isColored,hasColorOffsets,this->blend,this->antialiasing,this->shader);
            		}
HXLINE( 906)		 ::flixel::math::FlxPoint _hx_tmp2 = this->_point;
HXDLIN( 906)		_hx_tmp2->set_x((((Camera->scroll->x * this->scrollFactor->x) - this->x) - this->offset->x));
HXLINE( 907)		 ::flixel::math::FlxPoint _hx_tmp3 = this->_point;
HXDLIN( 907)		_hx_tmp3->set_y((((Camera->scroll->y * this->scrollFactor->y) - this->y) - this->offset->y));
HXLINE( 909)		int screenXInTiles = ::Math_obj::floor(((Float)this->_point->x / (Float)this->_scaledTileWidth));
HXLINE( 910)		int screenYInTiles = ::Math_obj::floor(((Float)this->_point->y / (Float)this->_scaledTileHeight));
HXLINE( 911)		int screenRows = Buffer->rows;
HXLINE( 912)		int screenColumns = Buffer->columns;
HXLINE( 915)		 ::Dynamic Max = (this->widthInTiles - screenColumns);
HXDLIN( 915)		Float lowerBound;
HXDLIN( 915)		if ((screenXInTiles < (int)0)) {
HXLINE( 915)			lowerBound = (int)0;
            		}
            		else {
HXLINE( 915)			lowerBound = screenXInTiles;
            		}
HXDLIN( 915)		Float screenXInTiles1;
HXDLIN( 915)		bool screenXInTiles2;
HXDLIN( 915)		if (hx::IsNotNull( Max )) {
HXLINE( 915)			screenXInTiles2 = hx::IsGreater( lowerBound,Max );
            		}
            		else {
HXLINE( 915)			screenXInTiles2 = false;
            		}
HXDLIN( 915)		if (screenXInTiles2) {
HXLINE( 915)			screenXInTiles1 = Max;
            		}
            		else {
HXLINE( 915)			screenXInTiles1 = lowerBound;
            		}
HXDLIN( 915)		screenXInTiles = ::Std_obj::_hx_int(screenXInTiles1);
HXLINE( 916)		 ::Dynamic Max1 = (this->heightInTiles - screenRows);
HXDLIN( 916)		Float lowerBound1;
HXDLIN( 916)		if ((screenYInTiles < (int)0)) {
HXLINE( 916)			lowerBound1 = (int)0;
            		}
            		else {
HXLINE( 916)			lowerBound1 = screenYInTiles;
            		}
HXDLIN( 916)		Float screenYInTiles1;
HXDLIN( 916)		bool screenYInTiles2;
HXDLIN( 916)		if (hx::IsNotNull( Max1 )) {
HXLINE( 916)			screenYInTiles2 = hx::IsGreater( lowerBound1,Max1 );
            		}
            		else {
HXLINE( 916)			screenYInTiles2 = false;
            		}
HXDLIN( 916)		if (screenYInTiles2) {
HXLINE( 916)			screenYInTiles1 = Max1;
            		}
            		else {
HXLINE( 916)			screenYInTiles1 = lowerBound1;
            		}
HXDLIN( 916)		screenYInTiles = ::Std_obj::_hx_int(screenYInTiles1);
HXLINE( 918)		int rowIndex = ((screenYInTiles * this->widthInTiles) + screenXInTiles);
HXLINE( 919)		this->_flashPoint->y = (int)0;
HXLINE( 920)		int columnIndex;
HXLINE( 921)		 ::flixel::tile::FlxTile tile;
HXLINE( 922)		 ::flixel::graphics::frames::FlxFrame frame;
HXLINE( 925)		 ::openfl::_legacy::display::BitmapData debugTile;
HXLINE( 928)		{
HXLINE( 928)			int _g1 = (int)0;
HXDLIN( 928)			int _g = screenRows;
HXDLIN( 928)			while((_g1 < _g)){
HXLINE( 928)				_g1 = (_g1 + (int)1);
HXDLIN( 928)				int row = (_g1 - (int)1);
HXLINE( 930)				columnIndex = rowIndex;
HXLINE( 931)				this->_flashPoint->x = (int)0;
HXLINE( 933)				{
HXLINE( 933)					int _g3 = (int)0;
HXDLIN( 933)					int _g2 = screenColumns;
HXDLIN( 933)					while((_g3 < _g2)){
HXLINE( 933)						_g3 = (_g3 + (int)1);
HXDLIN( 933)						int column = (_g3 - (int)1);
HXLINE( 935)						::Array< ::Dynamic> tile1 = this->_tileObjects;
HXDLIN( 935)						tile = tile1->__get(this->_data->__get(columnIndex)).StaticCast<  ::flixel::tile::FlxTile >();
HXLINE( 937)						bool _hx_tmp4;
HXDLIN( 937)						bool _hx_tmp5;
HXDLIN( 937)						if (hx::IsNotNull( tile )) {
HXLINE( 937)							_hx_tmp5 = tile->visible;
            						}
            						else {
HXLINE( 937)							_hx_tmp5 = false;
            						}
HXDLIN( 937)						if (_hx_tmp5) {
HXLINE( 937)							_hx_tmp4 = (tile->frame->type != (int)2);
            						}
            						else {
HXLINE( 937)							_hx_tmp4 = false;
            						}
HXDLIN( 937)						if (_hx_tmp4) {
HXLINE( 939)							frame = tile->frame;
HXLINE( 941)							if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 943)								frame->paint(Buffer->pixels,this->_flashPoint,true,null());
HXLINE( 946)								bool _hx_tmp6;
HXDLIN( 946)								if (::flixel::FlxG_obj::debugger->drawDebug) {
HXLINE( 946)									_hx_tmp6 = !(this->ignoreDrawDebug);
            								}
            								else {
HXLINE( 946)									_hx_tmp6 = false;
            								}
HXDLIN( 946)								if (_hx_tmp6) {
HXLINE( 948)									if ((tile->allowCollisions <= (int)0)) {
HXLINE( 950)										debugTile = this->_debugTileNotSolid;
            									}
            									else {
HXLINE( 952)										if ((tile->allowCollisions != (int)4369)) {
HXLINE( 954)											debugTile = this->_debugTilePartial;
            										}
            										else {
HXLINE( 958)											debugTile = this->_debugTileSolid;
            										}
            									}
HXLINE( 961)									{
HXLINE( 961)										 ::flixel::math::FlxPoint _this1 = this->offset;
HXDLIN( 961)										 ::openfl::_legacy::geom::Point FlashPoint1 = this->_flashPoint;
HXDLIN( 961)										 ::openfl::_legacy::geom::Point FlashPoint2 = FlashPoint1;
HXDLIN( 961)										FlashPoint2->x = (FlashPoint2->x + _this1->x);
HXDLIN( 961)										 ::openfl::_legacy::geom::Point FlashPoint3 = FlashPoint1;
HXDLIN( 961)										FlashPoint3->y = (FlashPoint3->y + _this1->y);
            									}
HXLINE( 962)									Buffer->pixels->copyPixels(debugTile,this->_debugRect,this->_flashPoint,null(),null(),true);
HXLINE( 963)									{
HXLINE( 963)										 ::flixel::math::FlxPoint _this2 = this->offset;
HXDLIN( 963)										 ::openfl::_legacy::geom::Point FlashPoint4 = this->_flashPoint;
HXDLIN( 963)										 ::openfl::_legacy::geom::Point FlashPoint5 = FlashPoint4;
HXDLIN( 963)										FlashPoint5->x = (FlashPoint5->x - _this2->x);
HXDLIN( 963)										 ::openfl::_legacy::geom::Point FlashPoint6 = FlashPoint4;
HXDLIN( 963)										FlashPoint6->y = (FlashPoint6->y - _this2->y);
            									}
            								}
            							}
            							else {
HXLINE( 969)								Float drawX1 = this->_helperPoint->x;
HXDLIN( 969)								drawX = (drawX1 + (hx::Mod(columnIndex,this->widthInTiles) * scaledWidth));
HXLINE( 970)								Float drawY1 = this->_helperPoint->y;
HXDLIN( 970)								drawY = (drawY1 + (::Math_obj::floor(((Float)columnIndex / (Float)this->widthInTiles)) * scaledHeight));
HXLINE( 972)								this->_matrix->identity();
HXLINE( 974)								if ((frame->angle != (int)0)) {
HXLINE( 976)									frame->prepareMatrix(this->_matrix,null(),null(),null());
            								}
HXLINE( 979)								Float scaleX = this->scale->x;
HXLINE( 980)								Float scaleY = this->scale->y;
HXLINE( 982)								if (this->useScaleHack) {
HXLINE( 984)									scaleX = (scaleX + ((Float)(int)1 / (Float)(frame->sourceSize->x * Camera->totalScaleX)));
HXLINE( 985)									scaleY = (scaleY + ((Float)(int)1 / (Float)(frame->sourceSize->y * Camera->totalScaleY)));
            								}
HXLINE( 988)								this->_matrix->scale(scaleX,scaleY);
HXLINE( 989)								this->_matrix->translate(drawX,drawY);
HXLINE( 991)								drawItem->addQuad(frame,this->_matrix,this->colorTransform);
            							}
            						}
HXLINE( 995)						if (::flixel::FlxG_obj::renderBlit) {
HXLINE( 996)							 ::openfl::_legacy::geom::Point _hx_tmp7 = this->_flashPoint;
HXDLIN( 996)							_hx_tmp7->x = (_hx_tmp7->x + this->_tileWidth);
            						}
HXLINE( 997)						columnIndex = (columnIndex + (int)1);
            					}
            				}
HXLINE(1000)				if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1001)					 ::openfl::_legacy::geom::Point _hx_tmp8 = this->_flashPoint;
HXDLIN(1001)					_hx_tmp8->y = (_hx_tmp8->y + this->_tileHeight);
            				}
HXLINE(1002)				rowIndex = (rowIndex + this->widthInTiles);
            			}
            		}
HXLINE(1005)		Buffer->x = (screenXInTiles * this->_scaledTileWidth);
HXLINE(1006)		Buffer->y = (screenYInTiles * this->_scaledTileHeight);
HXLINE(1008)		if (::flixel::FlxG_obj::renderBlit) {
HXLINE(1010)			if (isColored) {
HXLINE(1011)				Buffer->colorTransform(this->colorTransform);
            			}
HXLINE(1012)			Buffer->blend = this->blend;
            		}
HXLINE(1015)		Buffer->dirty = false;
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemap_obj,drawTilemap,(void))

 ::openfl::_legacy::display::BitmapData FlxTilemap_obj::makeDebugTile(int color){
            	HX_GC_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1024_makeDebugTile)
HXLINE(1025)		if (::flixel::FlxG_obj::renderTile) {
HXLINE(1026)			return null();
            		}
HXLINE(1028)		 ::openfl::_legacy::display::BitmapData debugTile =  ::openfl::_legacy::display::BitmapData_obj::__alloc( HX_CTX ,this->_tileWidth,this->_tileHeight,true,(int)0,null());
HXLINE(1029)		this->drawDebugTile(debugTile,color);
HXLINE(1030)		return debugTile;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,makeDebugTile,return )

void FlxTilemap_obj::drawDebugTile( ::openfl::_legacy::display::BitmapData debugTile,int color){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1035_drawDebugTile)
HXDLIN(1035)		if ((color != (int)0)) {
HXLINE(1037)			 ::openfl::_legacy::display::Graphics gfx = ::flixel::util::FlxSpriteUtil_obj::flashGfx;
HXLINE(1038)			gfx->clear();
HXLINE(1039)			gfx->moveTo((int)0,(int)0);
HXLINE(1040)			gfx->lineStyle((int)1,color,((Float)0.5),null(),null(),null(),null(),null());
HXLINE(1041)			gfx->lineTo((this->_tileWidth - (int)1),(int)0);
HXLINE(1042)			int _hx_tmp = (this->_tileWidth - (int)1);
HXDLIN(1042)			gfx->lineTo(_hx_tmp,(this->_tileHeight - (int)1));
HXLINE(1043)			gfx->lineTo((int)0,(this->_tileHeight - (int)1));
HXLINE(1044)			gfx->lineTo((int)0,(int)0);
HXLINE(1046)			debugTile->draw(::flixel::util::FlxSpriteUtil_obj::flashGfxSprite,null(),null(),null(),null(),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(FlxTilemap_obj,drawDebugTile,(void))

void FlxTilemap_obj::onDrawDebugChanged(){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1052_onDrawDebugChanged)
HXDLIN(1052)		this->setDirty(null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTilemap_obj,onDrawDebugChanged,(void))

void FlxTilemap_obj::updateTile(int Index){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1062_updateTile)
HXLINE(1063)		 ::flixel::tile::FlxTile tile = Dynamic( this->_tileObjects->__get(Index)).StaticCast<  ::flixel::tile::FlxTile >();
HXLINE(1064)		bool _hx_tmp;
HXDLIN(1064)		if (hx::IsNotNull( tile )) {
HXLINE(1064)			_hx_tmp = !(tile->visible);
            		}
            		else {
HXLINE(1064)			_hx_tmp = true;
            		}
HXDLIN(1064)		if (_hx_tmp) {
HXLINE(1065)			return;
            		}
HXLINE(1067)		::Array< ::Dynamic> _hx_tmp1 = this->frames->frames;
HXDLIN(1067)		tile->frame = _hx_tmp1->__get((Index - this->_startingIndex)).StaticCast<  ::flixel::graphics::frames::FlxFrame >();
            	}


 ::flixel::tile::FlxTilemapBuffer FlxTilemap_obj::createBuffer( ::flixel::FlxCamera camera){
            	HX_GC_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1071_createBuffer)
HXLINE(1072)		 ::flixel::tile::FlxTilemapBuffer buffer =  ::flixel::tile::FlxTilemapBuffer_obj::__alloc( HX_CTX ,this->_tileWidth,this->_tileHeight,this->widthInTiles,this->heightInTiles,camera,this->scale->x,this->scale->y);
HXLINE(1073)		buffer->pixelPerfectRender = this->pixelPerfectRender;
HXLINE(1074)		buffer->antialiasing = this->antialiasing;
HXLINE(1075)		return buffer;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,createBuffer,return )

bool FlxTilemap_obj::set_antialiasing(bool value){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1079_set_antialiasing)
HXLINE(1080)		{
HXLINE(1080)			int _g = (int)0;
HXDLIN(1080)			::Array< ::Dynamic> _g1 = this->_buffers;
HXDLIN(1080)			while((_g < _g1->length)){
HXLINE(1080)				 ::flixel::tile::FlxTilemapBuffer buffer = _g1->__get(_g).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXDLIN(1080)				_g = (_g + (int)1);
HXLINE(1081)				buffer->antialiasing = value;
            			}
            		}
HXLINE(1082)		return (this->antialiasing = value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,set_antialiasing,return )

 ::flixel::graphics::FlxGraphic FlxTilemap_obj::set_graphic( ::flixel::graphics::FlxGraphic Value){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1090_set_graphic)
HXLINE(1092)		if (hx::IsNotEq( this->graphic,Value )) {
HXLINE(1095)			if (hx::IsNotNull( Value )) {
HXLINE(1096)				 ::flixel::graphics::FlxGraphic _g = Value;
HXDLIN(1096)				int _g1 = _g->get_useCount();
HXDLIN(1096)				_g->set_useCount((_g1 + (int)1));
            			}
HXLINE(1099)			if (hx::IsNotNull( this->graphic )) {
HXLINE(1100)				 ::flixel::graphics::FlxGraphic _g2 = this->graphic;
HXDLIN(1100)				int _g11 = _g2->get_useCount();
HXDLIN(1100)				_g2->set_useCount((_g11 - (int)1));
            			}
            		}
HXLINE(1103)		return (this->graphic = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,set_graphic,return )

bool FlxTilemap_obj::set_pixelPerfectRender(bool Value){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1107_set_pixelPerfectRender)
HXLINE(1108)		if (hx::IsNotNull( this->_buffers )) {
HXLINE(1109)			int _g = (int)0;
HXDLIN(1109)			::Array< ::Dynamic> _g1 = this->_buffers;
HXDLIN(1109)			while((_g < _g1->length)){
HXLINE(1109)				 ::flixel::tile::FlxTilemapBuffer buffer = _g1->__get(_g).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXDLIN(1109)				_g = (_g + (int)1);
HXLINE(1110)				buffer->pixelPerfectRender = Value;
            			}
            		}
HXLINE(1112)		return (this->pixelPerfectRender = Value);
            	}


Float FlxTilemap_obj::set_alpha(Float Alpha){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1116_set_alpha)
HXLINE(1117)		Float lowerBound;
HXDLIN(1117)		if ((Alpha < (int)0)) {
HXLINE(1117)			lowerBound = (int)0;
            		}
            		else {
HXLINE(1117)			lowerBound = Alpha;
            		}
HXDLIN(1117)		 ::Dynamic _hx_tmp;
HXDLIN(1117)		if ((lowerBound > (int)1)) {
HXLINE(1117)			_hx_tmp = (int)1;
            		}
            		else {
HXLINE(1117)			_hx_tmp = lowerBound;
            		}
HXDLIN(1117)		this->alpha = _hx_tmp;
HXLINE(1118)		this->updateColorTransform();
HXLINE(1119)		return this->alpha;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,set_alpha,return )

int FlxTilemap_obj::set_color(int Color){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1123_set_color)
HXLINE(1124)		if ((this->color == Color)) {
HXLINE(1125)			return Color;
            		}
HXLINE(1127)		this->color = Color;
HXLINE(1128)		this->updateColorTransform();
HXLINE(1129)		return this->color;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,set_color,return )

void FlxTilemap_obj::updateColorTransform(){
            	HX_GC_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1133_updateColorTransform)
HXLINE(1134)		if (hx::IsNull( this->colorTransform )) {
HXLINE(1135)			this->colorTransform =  ::openfl::_legacy::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
            		}
HXLINE(1137)		bool _hx_tmp;
HXDLIN(1137)		if ((this->alpha == (int)1)) {
HXLINE(1137)			_hx_tmp = (this->color != (int)16777215);
            		}
            		else {
HXLINE(1137)			_hx_tmp = true;
            		}
HXDLIN(1137)		if (_hx_tmp) {
HXLINE(1138)			::flixel::util::FlxColorTransformUtil_obj::setMultipliers(this->colorTransform,((Float)((int)((int)this->color >> (int)(int)16) & (int)(int)255) / (Float)(int)255),((Float)((int)((int)this->color >> (int)(int)8) & (int)(int)255) / (Float)(int)255),((Float)((int)this->color & (int)(int)255) / (Float)(int)255),this->alpha);
            		}
            		else {
HXLINE(1140)			::flixel::util::FlxColorTransformUtil_obj::setMultipliers(this->colorTransform,(int)1,(int)1,(int)1,(int)1);
            		}
HXLINE(1142)		this->setDirty(null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(FlxTilemap_obj,updateColorTransform,(void))

 ::openfl::_legacy::display::BlendMode FlxTilemap_obj::set_blend( ::openfl::_legacy::display::BlendMode Value){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1146_set_blend)
HXLINE(1147)		this->setDirty(null());
HXLINE(1148)		return (this->blend = Value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,set_blend,return )

void FlxTilemap_obj::setScaleXYCallback( ::flixel::math::FlxPoint Scale){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1152_setScaleXYCallback)
HXLINE(1153)		this->setScaleXCallback(Scale);
HXLINE(1154)		this->setScaleYCallback(Scale);
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,setScaleXYCallback,(void))

void FlxTilemap_obj::setScaleXCallback( ::flixel::math::FlxPoint Scale){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1158_setScaleXCallback)
HXLINE(1159)		this->_scaledTileWidth = (this->_tileWidth * this->scale->x);
HXLINE(1160)		this->set_width((this->widthInTiles * this->_scaledTileWidth));
HXLINE(1162)		if (hx::IsNull( this->get_cameras() )) {
HXLINE(1163)			return;
            		}
HXLINE(1165)		{
HXLINE(1165)			int _g1 = (int)0;
HXDLIN(1165)			int _g = this->get_cameras()->length;
HXDLIN(1165)			while((_g1 < _g)){
HXLINE(1165)				_g1 = (_g1 + (int)1);
HXDLIN(1165)				int i = (_g1 - (int)1);
HXLINE(1166)				if (hx::IsNotNull( this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >() )) {
HXLINE(1167)					 ::flixel::tile::FlxTilemapBuffer _hx_tmp = this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXDLIN(1167)					int _hx_tmp1 = this->_tileWidth;
HXDLIN(1167)					int _hx_tmp2 = this->widthInTiles;
HXDLIN(1167)					Float _hx_tmp3 = this->scale->x;
HXDLIN(1167)					_hx_tmp->updateColumns(_hx_tmp1,_hx_tmp2,_hx_tmp3,this->get_cameras()->__get(i).StaticCast<  ::flixel::FlxCamera >());
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,setScaleXCallback,(void))

void FlxTilemap_obj::setScaleYCallback( ::flixel::math::FlxPoint Scale){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1171_setScaleYCallback)
HXLINE(1172)		this->_scaledTileHeight = (this->_tileHeight * this->scale->y);
HXLINE(1173)		this->set_height((this->heightInTiles * this->_scaledTileHeight));
HXLINE(1175)		if (hx::IsNull( this->get_cameras() )) {
HXLINE(1176)			return;
            		}
HXLINE(1178)		{
HXLINE(1178)			int _g1 = (int)0;
HXDLIN(1178)			int _g = this->get_cameras()->length;
HXDLIN(1178)			while((_g1 < _g)){
HXLINE(1178)				_g1 = (_g1 + (int)1);
HXDLIN(1178)				int i = (_g1 - (int)1);
HXLINE(1179)				if (hx::IsNotNull( this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >() )) {
HXLINE(1180)					 ::flixel::tile::FlxTilemapBuffer _hx_tmp = this->_buffers->__get(i).StaticCast<  ::flixel::tile::FlxTilemapBuffer >();
HXDLIN(1180)					int _hx_tmp1 = this->_tileHeight;
HXDLIN(1180)					int _hx_tmp2 = this->heightInTiles;
HXDLIN(1180)					Float _hx_tmp3 = this->scale->y;
HXDLIN(1180)					_hx_tmp->updateRows(_hx_tmp1,_hx_tmp2,_hx_tmp3,this->get_cameras()->__get(i).StaticCast<  ::flixel::FlxCamera >());
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,setScaleYCallback,(void))

 ::flixel::FlxSprite FlxTilemap_obj::defaultTileToSprite( ::Dynamic TileProperties){
            	HX_GC_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1190_defaultTileToSprite)
HXLINE(1191)		 ::flixel::FlxSprite tileSprite =  ::flixel::FlxSprite_obj::__alloc( HX_CTX , ::Dynamic(TileProperties->__Field(HX_("x",78,00,00,00),hx::paccDynamic)), ::Dynamic(TileProperties->__Field(HX_("y",79,00,00,00),hx::paccDynamic)),null());
HXLINE(1192)		tileSprite->set_frames(( ( ::flixel::graphics::frames::FlxFramesCollection)(TileProperties->__Field(HX_("graphic",a8,5a,07,74),hx::paccDynamic)) ));
HXLINE(1193)		{
HXLINE(1193)			 ::flixel::math::FlxPoint _this = tileSprite->scale;
HXDLIN(1193)			 ::flixel::math::FlxPoint point = ( ( ::flixel::math::FlxPoint)(TileProperties->__Field(HX_("scale",8a,ce,ce,78),hx::paccDynamic)) );
HXDLIN(1193)			_this->set_x(point->x);
HXDLIN(1193)			_this->set_y(point->y);
HXDLIN(1193)			if (point->_weak) {
HXLINE(1193)				point->put();
            			}
            		}
HXLINE(1194)		TileProperties->__SetField(HX_("scale",8a,ce,ce,78),( ( ::flixel::math::FlxPoint)(::flixel::util::FlxDestroyUtil_obj::put( ::Dynamic(TileProperties->__Field(HX_("scale",8a,ce,ce,78),hx::paccDynamic)))) ),hx::paccDynamic);
HXLINE(1195)		tileSprite->set_alpha(( (Float)(TileProperties->__Field(HX_("alpha",5e,a7,96,21),hx::paccDynamic)) ));
HXLINE(1196)		tileSprite->set_blend(TileProperties->__Field(HX_("blend",51,e8,f4,b4),hx::paccDynamic));
HXLINE(1197)		return tileSprite;
            	}


HX_DEFINE_DYNAMIC_FUNC1(FlxTilemap_obj,defaultTileToSprite,return )

int FlxTilemap_obj::set_allowCollisions(int Value){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1201_set_allowCollisions)
HXLINE(1202)		{
HXLINE(1202)			int _g = (int)0;
HXDLIN(1202)			::Array< ::Dynamic> _g1 = this->_tileObjects;
HXDLIN(1202)			while((_g < _g1->length)){
HXLINE(1202)				 ::flixel::tile::FlxTile tile = _g1->__get(_g).StaticCast<  ::flixel::tile::FlxTile >();
HXDLIN(1202)				_g = (_g + (int)1);
HXLINE(1203)				if ((tile->index >= this->_collideIndex)) {
HXLINE(1204)					tile->set_allowCollisions(Value);
            				}
            			}
            		}
HXLINE(1206)		return this->super::set_allowCollisions(Value);
            	}


int FlxTilemap_obj::set_debugBoundingBoxColorSolid(int color){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1211_set_debugBoundingBoxColorSolid)
HXLINE(1212)		this->super::set_debugBoundingBoxColorSolid(color);
HXLINE(1213)		this->updateDebugTileBoundingBoxSolid();
HXLINE(1214)		return color;
            	}


int FlxTilemap_obj::set_debugBoundingBoxColorNotSolid(int color){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1218_set_debugBoundingBoxColorNotSolid)
HXLINE(1219)		this->super::set_debugBoundingBoxColorNotSolid(color);
HXLINE(1220)		this->updateDebugTileBoundingBoxNotSolid();
HXLINE(1221)		return color;
            	}


int FlxTilemap_obj::set_debugBoundingBoxColorPartial(int color){
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_1225_set_debugBoundingBoxColorPartial)
HXLINE(1226)		this->super::set_debugBoundingBoxColorPartial(color);
HXLINE(1227)		this->updateDebugTileBoundingBoxPartial();
HXLINE(1228)		return color;
            	}


 ::flixel::tile::FlxTilemapBuffer FlxTilemap_obj::_helperBuffer;


hx::ObjectPtr< FlxTilemap_obj > FlxTilemap_obj::__new() {
	hx::ObjectPtr< FlxTilemap_obj > __this = new FlxTilemap_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< FlxTilemap_obj > FlxTilemap_obj::__alloc(hx::Ctx *_hx_ctx) {
	FlxTilemap_obj *__this = (FlxTilemap_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(FlxTilemap_obj), true, "flixel.tile.FlxTilemap"));
	*(void **)__this = FlxTilemap_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

FlxTilemap_obj::FlxTilemap_obj()
{
}

void FlxTilemap_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FlxTilemap);
	HX_MARK_MEMBER_NAME(useScaleHack,"useScaleHack");
	HX_MARK_MEMBER_NAME(scale,"scale");
	HX_MARK_MEMBER_NAME(antialiasing,"antialiasing");
	HX_MARK_MEMBER_NAME(offset,"offset");
	HX_MARK_MEMBER_NAME(frames,"frames");
	HX_MARK_MEMBER_NAME(graphic,"graphic");
	HX_MARK_MEMBER_NAME(color,"color");
	HX_MARK_MEMBER_NAME(alpha,"alpha");
	HX_MARK_MEMBER_NAME(colorTransform,"colorTransform");
	HX_MARK_MEMBER_NAME(blend,"blend");
	HX_MARK_MEMBER_NAME(shader,"shader");
	HX_MARK_MEMBER_NAME(_flashPoint,"_flashPoint");
	HX_MARK_MEMBER_NAME(_flashRect,"_flashRect");
	HX_MARK_MEMBER_NAME(_buffers,"_buffers");
	HX_MARK_MEMBER_NAME(_tileWidth,"_tileWidth");
	HX_MARK_MEMBER_NAME(_tileHeight,"_tileHeight");
	HX_MARK_MEMBER_NAME(_scaledTileWidth,"_scaledTileWidth");
	HX_MARK_MEMBER_NAME(_scaledTileHeight,"_scaledTileHeight");
	HX_MARK_MEMBER_NAME(_debugTileNotSolid,"_debugTileNotSolid");
	HX_MARK_MEMBER_NAME(_debugTilePartial,"_debugTilePartial");
	HX_MARK_MEMBER_NAME(_debugTileSolid,"_debugTileSolid");
	HX_MARK_MEMBER_NAME(_debugRect,"_debugRect");
	HX_MARK_MEMBER_NAME(_helperPoint,"_helperPoint");
	HX_MARK_MEMBER_NAME(_matrix,"_matrix");
	HX_MARK_MEMBER_NAME(_checkBufferChanges,"_checkBufferChanges");
	 ::flixel::tile::FlxBaseTilemap_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void FlxTilemap_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(useScaleHack,"useScaleHack");
	HX_VISIT_MEMBER_NAME(scale,"scale");
	HX_VISIT_MEMBER_NAME(antialiasing,"antialiasing");
	HX_VISIT_MEMBER_NAME(offset,"offset");
	HX_VISIT_MEMBER_NAME(frames,"frames");
	HX_VISIT_MEMBER_NAME(graphic,"graphic");
	HX_VISIT_MEMBER_NAME(color,"color");
	HX_VISIT_MEMBER_NAME(alpha,"alpha");
	HX_VISIT_MEMBER_NAME(colorTransform,"colorTransform");
	HX_VISIT_MEMBER_NAME(blend,"blend");
	HX_VISIT_MEMBER_NAME(shader,"shader");
	HX_VISIT_MEMBER_NAME(_flashPoint,"_flashPoint");
	HX_VISIT_MEMBER_NAME(_flashRect,"_flashRect");
	HX_VISIT_MEMBER_NAME(_buffers,"_buffers");
	HX_VISIT_MEMBER_NAME(_tileWidth,"_tileWidth");
	HX_VISIT_MEMBER_NAME(_tileHeight,"_tileHeight");
	HX_VISIT_MEMBER_NAME(_scaledTileWidth,"_scaledTileWidth");
	HX_VISIT_MEMBER_NAME(_scaledTileHeight,"_scaledTileHeight");
	HX_VISIT_MEMBER_NAME(_debugTileNotSolid,"_debugTileNotSolid");
	HX_VISIT_MEMBER_NAME(_debugTilePartial,"_debugTilePartial");
	HX_VISIT_MEMBER_NAME(_debugTileSolid,"_debugTileSolid");
	HX_VISIT_MEMBER_NAME(_debugRect,"_debugRect");
	HX_VISIT_MEMBER_NAME(_helperPoint,"_helperPoint");
	HX_VISIT_MEMBER_NAME(_matrix,"_matrix");
	HX_VISIT_MEMBER_NAME(_checkBufferChanges,"_checkBufferChanges");
	 ::flixel::tile::FlxBaseTilemap_obj::__Visit(HX_VISIT_ARG);
}

hx::Val FlxTilemap_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"ray") ) { return hx::Val( ray_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"scale") ) { return hx::Val( scale ); }
		if (HX_FIELD_EQ(inName,"color") ) { return hx::Val( color ); }
		if (HX_FIELD_EQ(inName,"alpha") ) { return hx::Val( alpha ); }
		if (HX_FIELD_EQ(inName,"blend") ) { return hx::Val( blend ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"offset") ) { return hx::Val( offset ); }
		if (HX_FIELD_EQ(inName,"frames") ) { return hx::Val( frames ); }
		if (HX_FIELD_EQ(inName,"shader") ) { return hx::Val( shader ); }
		if (HX_FIELD_EQ(inName,"follow") ) { return hx::Val( follow_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"graphic") ) { return hx::Val( graphic ); }
		if (HX_FIELD_EQ(inName,"_matrix") ) { return hx::Val( _matrix ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_buffers") ) { return hx::Val( _buffers ); }
		if (HX_FIELD_EQ(inName,"setDirty") ) { return hx::Val( setDirty_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"updateMap") ) { return hx::Val( updateMap_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_alpha") ) { return hx::Val( set_alpha_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_color") ) { return hx::Val( set_color_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_blend") ) { return hx::Val( set_blend_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_flashRect") ) { return hx::Val( _flashRect ); }
		if (HX_FIELD_EQ(inName,"_tileWidth") ) { return hx::Val( _tileWidth ); }
		if (HX_FIELD_EQ(inName,"_debugRect") ) { return hx::Val( _debugRect ); }
		if (HX_FIELD_EQ(inName,"set_frames") ) { return hx::Val( set_frames_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateTile") ) { return hx::Val( updateTile_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_flashPoint") ) { return hx::Val( _flashPoint ); }
		if (HX_FIELD_EQ(inName,"_tileHeight") ) { return hx::Val( _tileHeight ); }
		if (HX_FIELD_EQ(inName,"drawTilemap") ) { return hx::Val( drawTilemap_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_graphic") ) { return hx::Val( set_graphic_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"useScaleHack") ) { return hx::Val( useScaleHack ); }
		if (HX_FIELD_EQ(inName,"antialiasing") ) { return hx::Val( antialiasing ); }
		if (HX_FIELD_EQ(inName,"_helperPoint") ) { return hx::Val( _helperPoint ); }
		if (HX_FIELD_EQ(inName,"tileToSprite") ) { return hx::Val( tileToSprite_dyn() ); }
		if (HX_FIELD_EQ(inName,"createBuffer") ) { return hx::Val( createBuffer_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"onGameResized") ) { return hx::Val( onGameResized_dyn() ); }
		if (HX_FIELD_EQ(inName,"cacheGraphics") ) { return hx::Val( cacheGraphics_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTileCoords") ) { return hx::Val( getTileCoords_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateBuffers") ) { return hx::Val( updateBuffers_dyn() ); }
		if (HX_FIELD_EQ(inName,"makeDebugTile") ) { return hx::Val( makeDebugTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawDebugTile") ) { return hx::Val( drawDebugTile_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorTransform") ) { return hx::Val( colorTransform ); }
		if (HX_FIELD_EQ(inName,"refreshBuffers") ) { return hx::Val( refreshBuffers_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_debugTileSolid") ) { return hx::Val( _debugTileSolid ); }
		if (HX_FIELD_EQ(inName,"onCameraChanged") ) { return hx::Val( onCameraChanged_dyn() ); }
		if (HX_FIELD_EQ(inName,"initTileObjects") ) { return hx::Val( initTileObjects_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateDebugTile") ) { return hx::Val( updateDebugTile_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"_scaledTileWidth") ) { return hx::Val( _scaledTileWidth ); }
		if (HX_FIELD_EQ(inName,"set_antialiasing") ) { return hx::Val( set_antialiasing_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"_scaledTileHeight") ) { return hx::Val( _scaledTileHeight ); }
		if (HX_FIELD_EQ(inName,"_debugTilePartial") ) { return hx::Val( _debugTilePartial ); }
		if (HX_FIELD_EQ(inName,"computeDimensions") ) { return hx::Val( computeDimensions_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawDebugOnCamera") ) { return hx::Val( drawDebugOnCamera_dyn() ); }
		if (HX_FIELD_EQ(inName,"setScaleXCallback") ) { return hx::Val( setScaleXCallback_dyn() ); }
		if (HX_FIELD_EQ(inName,"setScaleYCallback") ) { return hx::Val( setScaleYCallback_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"_debugTileNotSolid") ) { return hx::Val( _debugTileNotSolid ); }
		if (HX_FIELD_EQ(inName,"onDrawDebugChanged") ) { return hx::Val( onDrawDebugChanged_dyn() ); }
		if (HX_FIELD_EQ(inName,"setScaleXYCallback") ) { return hx::Val( setScaleXYCallback_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_checkBufferChanges") ) { return hx::Val( _checkBufferChanges ); }
		if (HX_FIELD_EQ(inName,"defaultTileToSprite") ) { return hx::Val( defaultTileToSprite_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_allowCollisions") ) { return hx::Val( set_allowCollisions_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"overlapsWithCallback") ) { return hx::Val( overlapsWithCallback_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTileIndexByCoords") ) { return hx::Val( getTileIndexByCoords_dyn() ); }
		if (HX_FIELD_EQ(inName,"getTileCoordsByIndex") ) { return hx::Val( getTileCoordsByIndex_dyn() ); }
		if (HX_FIELD_EQ(inName,"updateColorTransform") ) { return hx::Val( updateColorTransform_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"set_pixelPerfectRender") ) { return hx::Val( set_pixelPerfectRender_dyn() ); }
		break;
	case 30:
		if (HX_FIELD_EQ(inName,"set_debugBoundingBoxColorSolid") ) { return hx::Val( set_debugBoundingBoxColorSolid_dyn() ); }
		break;
	case 31:
		if (HX_FIELD_EQ(inName,"updateDebugTileBoundingBoxSolid") ) { return hx::Val( updateDebugTileBoundingBoxSolid_dyn() ); }
		break;
	case 32:
		if (HX_FIELD_EQ(inName,"set_debugBoundingBoxColorPartial") ) { return hx::Val( set_debugBoundingBoxColorPartial_dyn() ); }
		break;
	case 33:
		if (HX_FIELD_EQ(inName,"updateDebugTileBoundingBoxPartial") ) { return hx::Val( updateDebugTileBoundingBoxPartial_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_debugBoundingBoxColorNotSolid") ) { return hx::Val( set_debugBoundingBoxColorNotSolid_dyn() ); }
		break;
	case 34:
		if (HX_FIELD_EQ(inName,"updateDebugTileBoundingBoxNotSolid") ) { return hx::Val( updateDebugTileBoundingBoxNotSolid_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool FlxTilemap_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"_helperBuffer") ) { outValue = ( _helperBuffer ); return true; }
	}
	return false;
}

hx::Val FlxTilemap_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"scale") ) { scale=inValue.Cast<  ::flixel::math::FlxPoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"color") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_color(inValue.Cast< int >()) );color=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"alpha") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_alpha(inValue.Cast< Float >()) );alpha=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"blend") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_blend(inValue.Cast<  ::openfl::_legacy::display::BlendMode >()) );blend=inValue.Cast<  ::openfl::_legacy::display::BlendMode >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"offset") ) { offset=inValue.Cast<  ::flixel::math::FlxPoint >(); return inValue; }
		if (HX_FIELD_EQ(inName,"frames") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_frames(inValue.Cast<  ::flixel::graphics::frames::FlxFramesCollection >()) );frames=inValue.Cast<  ::flixel::graphics::frames::FlxFramesCollection >(); return inValue; }
		if (HX_FIELD_EQ(inName,"shader") ) { shader=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"graphic") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_graphic(inValue.Cast<  ::flixel::graphics::FlxGraphic >()) );graphic=inValue.Cast<  ::flixel::graphics::FlxGraphic >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_matrix") ) { _matrix=inValue.Cast<  ::flixel::math::FlxMatrix >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"_buffers") ) { _buffers=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_flashRect") ) { _flashRect=inValue.Cast<  ::openfl::_legacy::geom::Rectangle >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_tileWidth") ) { _tileWidth=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_debugRect") ) { _debugRect=inValue.Cast<  ::openfl::_legacy::geom::Rectangle >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_flashPoint") ) { _flashPoint=inValue.Cast<  ::openfl::_legacy::geom::Point >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_tileHeight") ) { _tileHeight=inValue.Cast< int >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"useScaleHack") ) { useScaleHack=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"antialiasing") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_antialiasing(inValue.Cast< bool >()) );antialiasing=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_helperPoint") ) { _helperPoint=inValue.Cast<  ::openfl::_legacy::geom::Point >(); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"colorTransform") ) { colorTransform=inValue.Cast<  ::openfl::_legacy::geom::ColorTransform >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"_debugTileSolid") ) { _debugTileSolid=inValue.Cast<  ::openfl::_legacy::display::BitmapData >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"_scaledTileWidth") ) { _scaledTileWidth=inValue.Cast< Float >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"_scaledTileHeight") ) { _scaledTileHeight=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_debugTilePartial") ) { _debugTilePartial=inValue.Cast<  ::openfl::_legacy::display::BitmapData >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"_debugTileNotSolid") ) { _debugTileNotSolid=inValue.Cast<  ::openfl::_legacy::display::BitmapData >(); return inValue; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"_checkBufferChanges") ) { _checkBufferChanges=inValue.Cast< bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool FlxTilemap_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"_helperBuffer") ) { _helperBuffer=ioValue.Cast<  ::flixel::tile::FlxTilemapBuffer >(); return true; }
	}
	return false;
}

void FlxTilemap_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("useScaleHack","\x44","\x9c","\x16","\x98"));
	outFields->push(HX_HCSTRING("scale","\x8a","\xce","\xce","\x78"));
	outFields->push(HX_HCSTRING("antialiasing","\xf4","\x16","\xb3","\x48"));
	outFields->push(HX_HCSTRING("offset","\x93","\x97","\x3f","\x60"));
	outFields->push(HX_HCSTRING("frames","\xa6","\xaf","\x85","\xac"));
	outFields->push(HX_HCSTRING("graphic","\xa8","\x5a","\x07","\x74"));
	outFields->push(HX_HCSTRING("color","\x63","\x71","\x5c","\x4a"));
	outFields->push(HX_HCSTRING("alpha","\x5e","\xa7","\x96","\x21"));
	outFields->push(HX_HCSTRING("colorTransform","\x89","\xd7","\x3f","\xad"));
	outFields->push(HX_HCSTRING("blend","\x51","\xe8","\xf4","\xb4"));
	outFields->push(HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"));
	outFields->push(HX_HCSTRING("_flashPoint","\x9f","\x1d","\x2a","\xb7"));
	outFields->push(HX_HCSTRING("_flashRect","\xb5","\xc2","\xf3","\x5d"));
	outFields->push(HX_HCSTRING("_buffers","\xf4","\xfc","\x48","\xeb"));
	outFields->push(HX_HCSTRING("_tileWidth","\xb9","\x8f","\x60","\xb1"));
	outFields->push(HX_HCSTRING("_tileHeight","\xd4","\xaa","\x6c","\x39"));
	outFields->push(HX_HCSTRING("_scaledTileWidth","\x7f","\x28","\x09","\x38"));
	outFields->push(HX_HCSTRING("_scaledTileHeight","\x4e","\xbf","\x49","\x86"));
	outFields->push(HX_HCSTRING("_debugTileNotSolid","\x1a","\xdf","\x89","\x53"));
	outFields->push(HX_HCSTRING("_debugTilePartial","\xbf","\x14","\x2d","\x78"));
	outFields->push(HX_HCSTRING("_debugTileSolid","\xe9","\x85","\xdf","\xf6"));
	outFields->push(HX_HCSTRING("_debugRect","\xd8","\x6c","\x95","\x8a"));
	outFields->push(HX_HCSTRING("_helperPoint","\x03","\xe6","\x14","\xf8"));
	outFields->push(HX_HCSTRING("_matrix","\xe0","\x47","\x3f","\x2a"));
	outFields->push(HX_HCSTRING("_checkBufferChanges","\x1a","\x1a","\x89","\x0b"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo FlxTilemap_obj_sMemberStorageInfo[] = {
	{hx::fsBool,(int)offsetof(FlxTilemap_obj,useScaleHack),HX_HCSTRING("useScaleHack","\x44","\x9c","\x16","\x98")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(int)offsetof(FlxTilemap_obj,scale),HX_HCSTRING("scale","\x8a","\xce","\xce","\x78")},
	{hx::fsBool,(int)offsetof(FlxTilemap_obj,antialiasing),HX_HCSTRING("antialiasing","\xf4","\x16","\xb3","\x48")},
	{hx::fsObject /*::flixel::math::FlxPoint*/ ,(int)offsetof(FlxTilemap_obj,offset),HX_HCSTRING("offset","\x93","\x97","\x3f","\x60")},
	{hx::fsObject /*::flixel::graphics::frames::FlxFramesCollection*/ ,(int)offsetof(FlxTilemap_obj,frames),HX_HCSTRING("frames","\xa6","\xaf","\x85","\xac")},
	{hx::fsObject /*::flixel::graphics::FlxGraphic*/ ,(int)offsetof(FlxTilemap_obj,graphic),HX_HCSTRING("graphic","\xa8","\x5a","\x07","\x74")},
	{hx::fsInt,(int)offsetof(FlxTilemap_obj,color),HX_HCSTRING("color","\x63","\x71","\x5c","\x4a")},
	{hx::fsFloat,(int)offsetof(FlxTilemap_obj,alpha),HX_HCSTRING("alpha","\x5e","\xa7","\x96","\x21")},
	{hx::fsObject /*::openfl::_legacy::geom::ColorTransform*/ ,(int)offsetof(FlxTilemap_obj,colorTransform),HX_HCSTRING("colorTransform","\x89","\xd7","\x3f","\xad")},
	{hx::fsObject /*::openfl::_legacy::display::BlendMode*/ ,(int)offsetof(FlxTilemap_obj,blend),HX_HCSTRING("blend","\x51","\xe8","\xf4","\xb4")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(FlxTilemap_obj,shader),HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d")},
	{hx::fsObject /*::openfl::_legacy::geom::Point*/ ,(int)offsetof(FlxTilemap_obj,_flashPoint),HX_HCSTRING("_flashPoint","\x9f","\x1d","\x2a","\xb7")},
	{hx::fsObject /*::openfl::_legacy::geom::Rectangle*/ ,(int)offsetof(FlxTilemap_obj,_flashRect),HX_HCSTRING("_flashRect","\xb5","\xc2","\xf3","\x5d")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(FlxTilemap_obj,_buffers),HX_HCSTRING("_buffers","\xf4","\xfc","\x48","\xeb")},
	{hx::fsInt,(int)offsetof(FlxTilemap_obj,_tileWidth),HX_HCSTRING("_tileWidth","\xb9","\x8f","\x60","\xb1")},
	{hx::fsInt,(int)offsetof(FlxTilemap_obj,_tileHeight),HX_HCSTRING("_tileHeight","\xd4","\xaa","\x6c","\x39")},
	{hx::fsFloat,(int)offsetof(FlxTilemap_obj,_scaledTileWidth),HX_HCSTRING("_scaledTileWidth","\x7f","\x28","\x09","\x38")},
	{hx::fsFloat,(int)offsetof(FlxTilemap_obj,_scaledTileHeight),HX_HCSTRING("_scaledTileHeight","\x4e","\xbf","\x49","\x86")},
	{hx::fsObject /*::openfl::_legacy::display::BitmapData*/ ,(int)offsetof(FlxTilemap_obj,_debugTileNotSolid),HX_HCSTRING("_debugTileNotSolid","\x1a","\xdf","\x89","\x53")},
	{hx::fsObject /*::openfl::_legacy::display::BitmapData*/ ,(int)offsetof(FlxTilemap_obj,_debugTilePartial),HX_HCSTRING("_debugTilePartial","\xbf","\x14","\x2d","\x78")},
	{hx::fsObject /*::openfl::_legacy::display::BitmapData*/ ,(int)offsetof(FlxTilemap_obj,_debugTileSolid),HX_HCSTRING("_debugTileSolid","\xe9","\x85","\xdf","\xf6")},
	{hx::fsObject /*::openfl::_legacy::geom::Rectangle*/ ,(int)offsetof(FlxTilemap_obj,_debugRect),HX_HCSTRING("_debugRect","\xd8","\x6c","\x95","\x8a")},
	{hx::fsObject /*::openfl::_legacy::geom::Point*/ ,(int)offsetof(FlxTilemap_obj,_helperPoint),HX_HCSTRING("_helperPoint","\x03","\xe6","\x14","\xf8")},
	{hx::fsObject /*::flixel::math::FlxMatrix*/ ,(int)offsetof(FlxTilemap_obj,_matrix),HX_HCSTRING("_matrix","\xe0","\x47","\x3f","\x2a")},
	{hx::fsBool,(int)offsetof(FlxTilemap_obj,_checkBufferChanges),HX_HCSTRING("_checkBufferChanges","\x1a","\x1a","\x89","\x0b")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo FlxTilemap_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::flixel::tile::FlxTilemapBuffer*/ ,(void *) &FlxTilemap_obj::_helperBuffer,HX_HCSTRING("_helperBuffer","\xed","\x07","\x9b","\xf3")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String FlxTilemap_obj_sMemberFields[] = {
	HX_HCSTRING("useScaleHack","\x44","\x9c","\x16","\x98"),
	HX_HCSTRING("scale","\x8a","\xce","\xce","\x78"),
	HX_HCSTRING("antialiasing","\xf4","\x16","\xb3","\x48"),
	HX_HCSTRING("offset","\x93","\x97","\x3f","\x60"),
	HX_HCSTRING("frames","\xa6","\xaf","\x85","\xac"),
	HX_HCSTRING("graphic","\xa8","\x5a","\x07","\x74"),
	HX_HCSTRING("color","\x63","\x71","\x5c","\x4a"),
	HX_HCSTRING("alpha","\x5e","\xa7","\x96","\x21"),
	HX_HCSTRING("colorTransform","\x89","\xd7","\x3f","\xad"),
	HX_HCSTRING("blend","\x51","\xe8","\xf4","\xb4"),
	HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"),
	HX_HCSTRING("_flashPoint","\x9f","\x1d","\x2a","\xb7"),
	HX_HCSTRING("_flashRect","\xb5","\xc2","\xf3","\x5d"),
	HX_HCSTRING("_buffers","\xf4","\xfc","\x48","\xeb"),
	HX_HCSTRING("_tileWidth","\xb9","\x8f","\x60","\xb1"),
	HX_HCSTRING("_tileHeight","\xd4","\xaa","\x6c","\x39"),
	HX_HCSTRING("_scaledTileWidth","\x7f","\x28","\x09","\x38"),
	HX_HCSTRING("_scaledTileHeight","\x4e","\xbf","\x49","\x86"),
	HX_HCSTRING("_debugTileNotSolid","\x1a","\xdf","\x89","\x53"),
	HX_HCSTRING("_debugTilePartial","\xbf","\x14","\x2d","\x78"),
	HX_HCSTRING("_debugTileSolid","\xe9","\x85","\xdf","\xf6"),
	HX_HCSTRING("_debugRect","\xd8","\x6c","\x95","\x8a"),
	HX_HCSTRING("_helperPoint","\x03","\xe6","\x14","\xf8"),
	HX_HCSTRING("_matrix","\xe0","\x47","\x3f","\x2a"),
	HX_HCSTRING("_checkBufferChanges","\x1a","\x1a","\x89","\x0b"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("set_frames","\xe3","\xbd","\x8a","\xa0"),
	HX_HCSTRING("onGameResized","\x3f","\xef","\x13","\xab"),
	HX_HCSTRING("onCameraChanged","\x30","\x48","\x4e","\x5c"),
	HX_HCSTRING("cacheGraphics","\x2d","\x61","\x95","\xfc"),
	HX_HCSTRING("initTileObjects","\x16","\xbe","\x45","\x2e"),
	HX_HCSTRING("updateDebugTileBoundingBoxSolid","\x9c","\x41","\x64","\xd8"),
	HX_HCSTRING("updateDebugTileBoundingBoxNotSolid","\x47","\x35","\xbd","\x4d"),
	HX_HCSTRING("updateDebugTileBoundingBoxPartial","\x32","\x63","\x1e","\x51"),
	HX_HCSTRING("updateDebugTile","\xd8","\x3f","\xd3","\x7f"),
	HX_HCSTRING("computeDimensions","\xa4","\xa4","\xeb","\xf3"),
	HX_HCSTRING("updateMap","\x13","\xe8","\xdf","\x82"),
	HX_HCSTRING("drawDebugOnCamera","\xf3","\x47","\x7b","\xcb"),
	HX_HCSTRING("draw","\x04","\x2c","\x70","\x42"),
	HX_HCSTRING("refreshBuffers","\xd8","\xb2","\xa5","\x26"),
	HX_HCSTRING("setDirty","\x10","\xb9","\x04","\xe8"),
	HX_HCSTRING("overlapsWithCallback","\x17","\xc3","\x72","\xa8"),
	HX_HCSTRING("getTileIndexByCoords","\x03","\x79","\x8b","\x76"),
	HX_HCSTRING("getTileCoordsByIndex","\xb9","\x63","\x25","\xa1"),
	HX_HCSTRING("getTileCoords","\x22","\xd6","\x8d","\x89"),
	HX_HCSTRING("follow","\x71","\x91","\x96","\xf9"),
	HX_HCSTRING("ray","\xea","\xd5","\x56","\x00"),
	HX_HCSTRING("tileToSprite","\x2e","\xe9","\x26","\xc3"),
	HX_HCSTRING("updateBuffers","\x6a","\x08","\xff","\x7c"),
	HX_HCSTRING("drawTilemap","\x8a","\x34","\xd7","\x8e"),
	HX_HCSTRING("makeDebugTile","\x53","\x67","\xf1","\x28"),
	HX_HCSTRING("drawDebugTile","\x7d","\x82","\x6f","\x8f"),
	HX_HCSTRING("onDrawDebugChanged","\x44","\xe0","\xf1","\x9f"),
	HX_HCSTRING("updateTile","\xd7","\xb5","\xb1","\x05"),
	HX_HCSTRING("createBuffer","\x1c","\xfd","\xe9","\xf2"),
	HX_HCSTRING("set_antialiasing","\xf1","\xf0","\x93","\xa3"),
	HX_HCSTRING("set_graphic","\xcb","\xc1","\x6e","\x04"),
	HX_HCSTRING("set_pixelPerfectRender","\x9a","\x4f","\x8f","\xbc"),
	HX_HCSTRING("set_alpha","\xc1","\xef","\x90","\x48"),
	HX_HCSTRING("set_color","\xc6","\xb9","\x56","\x71"),
	HX_HCSTRING("updateColorTransform","\x72","\x0f","\xd2","\x2f"),
	HX_HCSTRING("set_blend","\xb4","\x30","\xef","\xdb"),
	HX_HCSTRING("setScaleXYCallback","\x6e","\xfd","\x35","\x90"),
	HX_HCSTRING("setScaleXCallback","\xb5","\x05","\xa2","\x03"),
	HX_HCSTRING("setScaleYCallback","\xb6","\x6e","\x93","\xd6"),
	HX_HCSTRING("defaultTileToSprite","\x8f","\xab","\x7f","\x3f"),
	HX_HCSTRING("set_allowCollisions","\xcd","\x8b","\x81","\x21"),
	HX_HCSTRING("set_debugBoundingBoxColorSolid","\x19","\xc9","\x0b","\x4b"),
	HX_HCSTRING("set_debugBoundingBoxColorNotSolid","\xea","\xb9","\xe3","\x4b"),
	HX_HCSTRING("set_debugBoundingBoxColorPartial","\xef","\x83","\x54","\x62"),
	::String(null()) };

static void FlxTilemap_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FlxTilemap_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(FlxTilemap_obj::_helperBuffer,"_helperBuffer");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FlxTilemap_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FlxTilemap_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(FlxTilemap_obj::_helperBuffer,"_helperBuffer");
};

#endif

hx::Class FlxTilemap_obj::__mClass;

static ::String FlxTilemap_obj_sStaticFields[] = {
	HX_HCSTRING("_helperBuffer","\xed","\x07","\x9b","\xf3"),
	::String(null())
};

void FlxTilemap_obj::__register()
{
	hx::Object *dummy = new FlxTilemap_obj;
	FlxTilemap_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("flixel.tile.FlxTilemap","\x2a","\xd5","\x63","\x29");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &FlxTilemap_obj::__GetStatic;
	__mClass->mSetStaticField = &FlxTilemap_obj::__SetStatic;
	__mClass->mMarkFunc = FlxTilemap_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(FlxTilemap_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FlxTilemap_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FlxTilemap_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FlxTilemap_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FlxTilemap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FlxTilemap_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void FlxTilemap_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_1146cbfc6764fb25_49_boot)
HXDLIN(  49)		_helperBuffer = ( ( ::flixel::tile::FlxTilemapBuffer)(::Type_obj::createEmptyInstance(hx::ClassOf< ::flixel::tile::FlxTilemapBuffer >())) );
            	}
}

} // end namespace flixel
} // end namespace tile
